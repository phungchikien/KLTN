#!/bin/bash

# =================================================================
# SIEGE HTTP FLOOD TRAFFIC SIMULATOR WITH PYTHON MATH ENGINE
# =================================================================
# Advanced HTTP GET/POST flood simulation với TC qdisc control
# Python-powered mathematical traffic pattern generation

# Cấu hình mặc định
TARGET_URL="${1:-http://localhost:3000}"
INTERFACE="${2:-eth0}"
DURATION="${3:-300}"
TIME_COMPRESSION="${4:-72}"
FLOOD_TYPE="${5:-GET}"
LOG_FILE="siege_traffic_$(date +%Y%m%d_%H%M%S).log"
VERBOSE=true

# Cấu hình TC QDISC
BURST_SIZE="64k"
LATENCY="200ms"
MIN_RATE="1kbit"
MAX_RATE="1gbit"

# Cấu hình Siege
SIEGE_CONCURRENT="${SIEGE_CONCURRENT:-50}"
SIEGE_DELAY="${SIEGE_DELAY:-0}"
SIEGE_TIMEOUT="${SIEGE_TIMEOUT:-5}"

# PID và flags
SIEGE_PID=""
TC_ACTIVE=false
PYTHON_AVAILABLE=false

# Hàm logging
log() {
    local message="$1"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo "[$timestamp] $message" | tee -a "$LOG_FILE"
}

# Hàm cleanup
cleanup() {
    log "=== CLEANUP STARTED ==="
    
    # Kill siege process
    if [ -n "$SIEGE_PID" ] && kill -0 "$SIEGE_PID" 2>/dev/null; then
        log "Killing siege process (PID: $SIEGE_PID)"
        kill -TERM "$SIEGE_PID"
        sleep 2
        if kill -0 "$SIEGE_PID" 2>/dev/null; then
            kill -KILL "$SIEGE_PID"
        fi
        wait "$SIEGE_PID" 2>/dev/null
    fi
    
    # Kill all siege child processes
    pkill -9 siege 2>/dev/null
    
    # Remove TC qdisc
    if [ "$TC_ACTIVE" = true ]; then
        log "Removing tc qdisc from interface $INTERFACE"
        tc qdisc del dev "$INTERFACE" root 2>/dev/null || true
        TC_ACTIVE=false
    fi
    
    # Cleanup temp files
    rm -f /tmp/siege_urls.txt
    rm -f /tmp/siege_post_data.json
    rm -f /tmp/traffic_calculator.py
    
    log "=== CLEANUP COMPLETED ==="
    exit 0
}

trap cleanup EXIT INT TERM

# Kiểm tra Python availability
check_python() {
    if command -v python3 &> /dev/null; then
        if python3 -c "import math; print('OK')" &>/dev/null; then
            PYTHON_AVAILABLE=true
            log "Python3 with math module: Available"
            return 0
        fi
    fi
    
    if command -v python &> /dev/null; then
        if python -c "import math; print('OK')" &>/dev/null; then
            PYTHON_AVAILABLE=true
            log "Python with math module: Available"
            return 0
        fi
    fi
    
    log "WARNING: Python not available, using simplified math"
    PYTHON_AVAILABLE=false
    return 1
}

# Python traffic calculator
create_python_calculator() {
    cat << 'PYTHON_SCRIPT' > /tmp/traffic_calculator.py
#!/usr/bin/env python3
import math
import sys
import random

def calculate_hourly_requests(hour, scale_factor=100):
    """Tính toán HTTP requests theo giờ với realistic patterns"""
    # Morning peak (9 AM)
    morning_peak = 30 * math.exp(-((hour - 9) ** 2) / 6.25)
    
    # Lunch dip (12-1 PM)
    lunch_dip = -10 * math.exp(-((hour - 12.5) ** 2) / 1.5)
    
    # Evening peak (8 PM)
    evening_peak = 50 * math.exp(-((hour - 20) ** 2) / 7.84)
    
    # Night drop (2-4 AM)
    night_drop = -20 * math.exp(-((hour - 3) ** 2) / 3.24)
    
    # Daily cycle
    daily_cycle = 8 * math.sin(math.pi * hour / 12 - math.pi/2)
    
    # Base level
    base_level = 25
    
    # Combine factors
    traffic_factor = base_level + morning_peak + lunch_dip + evening_peak + night_drop + daily_cycle
    
    # Calculate concurrent users (min 5, max 200)
    concurrent = max(5, min(200, int(traffic_factor * scale_factor / 100)))
    
    return concurrent

def calculate_weekly_multiplier(day_of_week):
    """Hệ số nhân theo ngày trong tuần"""
    base = 87
    sine_component = 10 * math.sin(2 * math.pi * day_of_week / 7 + math.pi/7)
    weekend_spike = 8 * math.exp(-((day_of_week - 6) ** 2) / 2.25)
    weekly_factor = (base + sine_component + weekend_spike) / base
    return weekly_factor

def calculate_minute_variation(minute_in_hour):
    """Biến động theo phút"""
    return 1 + 0.25 * math.sin(2 * math.pi * minute_in_hour / 60)

def get_compressed_time(elapsed_seconds, compression_factor):
    """Tính toán thời gian ảo"""
    virtual_hours = elapsed_seconds * compression_factor / 3600
    current_hour = int(virtual_hours % 24)
    
    virtual_days = virtual_hours / 24
    day_of_week = int(virtual_days % 7) + 1
    
    seconds_in_hour = (elapsed_seconds * compression_factor) % 3600
    minute_in_hour = int(seconds_in_hour / 60)
    
    return current_hour, day_of_week, minute_in_hour

def calculate_concurrent_users(elapsed_seconds, compression_factor):
    """Tính toán số concurrent users cho Siege"""
    hour, day, minute = get_compressed_time(elapsed_seconds, compression_factor)
    
    # Base concurrent users
    base_concurrent = calculate_hourly_requests(hour)
    
    # Apply weekly multiplier
    weekly_mult = calculate_weekly_multiplier(day)
    
    # Apply minute variation
    minute_var = calculate_minute_variation(minute)
    
    # Combine factors
    final_concurrent = int(base_concurrent * weekly_mult * minute_var)
    
    # Add random noise (±15%)
    noise = random.uniform(0.85, 1.15)
    final_concurrent = int(final_concurrent * noise)
    
    # Clamp values
    final_concurrent = max(5, min(500, final_concurrent))
    
    return final_concurrent, hour, day, minute

def calculate_yoyo_concurrent(elapsed_seconds, cycle_duration=20, yoyo_type="square"):
    """Yo-yo patterns cho concurrent users"""
    cycle_position = (elapsed_seconds % cycle_duration) / cycle_duration
    
    if yoyo_type == "square":
        return 200 if cycle_position < 0.5 else 20
    elif yoyo_type == "sawtooth":
        if cycle_position < 0.8:
            return int(20 + 180 * cycle_position / 0.8)
        else:
            return 20
    elif yoyo_type == "burst":
        if cycle_position < 0.1:
            return 300
        elif cycle_position < 0.2:
            return 150
        else:
            return 30
    elif yoyo_type == "wave":
        return int(100 + 80 * math.sin(2 * math.pi * cycle_position))
    else:
        return 100

if __name__ == "__main__":
    if len(sys.argv) < 3:
        print("Usage: python3 traffic_calculator.py <mode> <elapsed_seconds> [args]")
        sys.exit(1)
    
    mode = sys.argv[1]
    elapsed_seconds = float(sys.argv[2])
    
    if mode == "compressed":
        compression_factor = float(sys.argv[3]) if len(sys.argv) > 3 else 72
        concurrent, hour, day, minute = calculate_concurrent_users(elapsed_seconds, compression_factor)
        print(f"{concurrent} {hour} {day} {minute}")
    
    elif mode == "yoyo":
        yoyo_type = sys.argv[3] if len(sys.argv) > 3 else "square"
        concurrent = calculate_yoyo_concurrent(elapsed_seconds, yoyo_type=yoyo_type)
        cycle_pos = (elapsed_seconds % 20) / 20
        print(f"{concurrent} {cycle_pos:.2f}")
    
    else:
        print("Unknown mode")
        sys.exit(1)
PYTHON_SCRIPT
    
    chmod +x /tmp/traffic_calculator.py
}

# Fallback math cho khi không có Python
calculate_simple_concurrent() {
    local hour=$1
    local day=$2
    local minute=$3
    
    local base_concurrent=50
    
    # Hour-based variation
    if [ $hour -ge 8 ] && [ $hour -le 10 ]; then
        base_concurrent=100  # Morning peak
    elif [ $hour -ge 19 ] && [ $hour -le 21 ]; then
        base_concurrent=150  # Evening peak
    elif [ $hour -ge 1 ] && [ $hour -le 5 ]; then
        base_concurrent=20   # Night low
    fi
    
    # Weekend boost
    if [ $day -eq 6 ] || [ $day -eq 7 ]; then
        base_concurrent=$(echo "scale=0; $base_concurrent * 1.3 / 1" | bc -l)
    fi
    
    echo "$base_concurrent"
}

# Chuyển đổi concurrent users sang bandwidth estimate
concurrent_to_bandwidth() {
    local concurrent=$1
    local avg_request_size=2000  # bytes per request
    local requests_per_second=$(echo "scale=0; $concurrent * 2" | bc -l)  # estimate
    
    local bps=$(echo "scale=0; $requests_per_second * $avg_request_size * 8" | bc -l)
    
    if [ $(echo "$bps >= 1000000000" | bc -l) -eq 1 ]; then
        local gbps=$(echo "scale=2; $bps / 1000000000" | bc -l)
        echo "${gbps}gbit"
    elif [ $(echo "$bps >= 1000000" | bc -l) -eq 1 ]; then
        local mbps=$(echo "scale=2; $bps / 1000000" | bc -l)
        echo "${mbps}mbit"
    elif [ $(echo "$bps >= 1000" | bc -l) -eq 1 ]; then
        local kbps=$(echo "scale=0; $bps / 1000" | bc -l)
        echo "${kbps}kbit"
    else
        echo "1kbit"
    fi
}

# TC qdisc functions
init_tc_qdisc() {
    log "Initializing TC qdisc on interface $INTERFACE"
    tc qdisc del dev "$INTERFACE" root 2>/dev/null || true
    
    if tc qdisc add dev "$INTERFACE" root tbf rate "$MIN_RATE" burst "$BURST_SIZE" latency "$LATENCY"; then
        TC_ACTIVE=true
        log "TC qdisc initialized successfully"
        return 0
    else
        log "ERROR: Failed to initialize TC qdisc"
        return 1
    fi
}

update_tc_rate() {
    local new_rate="$1"
    
    if [ "$TC_ACTIVE" = true ]; then
        if tc qdisc change dev "$INTERFACE" root tbf rate "$new_rate" burst "$BURST_SIZE" latency "$LATENCY" 2>/dev/null; then
            return 0
        else
            log "WARNING: Failed to update TC rate, reinitializing..."
            tc qdisc del dev "$INTERFACE" root 2>/dev/null || true
            if tc qdisc add dev "$INTERFACE" root tbf rate "$new_rate" burst "$BURST_SIZE" latency "$LATENCY"; then
                return 0
            else
                log "ERROR: Failed to reinitialize TC qdisc"
                TC_ACTIVE=false
                return 1
            fi
        fi
    fi
}

# Tạo siege configuration
create_siege_config() {
    local concurrent=$1
    
    # Create URLs file
    echo "$TARGET_URL" > /tmp/siege_urls.txt
    
    # Create POST data if needed
    if [ "$FLOOD_TYPE" = "POST" ]; then
        cat > /tmp/siege_post_data.json << EOF
{
  "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
  "user_id": "load_test_user",
  "session": "$(uuidgen 2>/dev/null || echo "test-session-$RANDOM")",
  "data": "Automated load test data from siege traffic simulator"
}
EOF
    fi
}

# Start Siege với dynamic concurrent users
start_siege_flood() {
    local concurrent=$1
    local flood_type=$2
    
    create_siege_config "$concurrent"
    
    log "Starting Siege flood: Type=$flood_type, Concurrent=$concurrent"
    
    # Kill existing siege processes
    pkill -9 siege 2>/dev/null || true
    sleep 1
    
    if [ "$flood_type" = "POST" ]; then
        # POST flood
        siege \
            --concurrent=$concurrent \
            --time=999H \
            --delay=$SIEGE_DELAY \
            --timeout=$SIEGE_TIMEOUT \
            --content-type="application/json" \
            --header="User-Agent: Siege-Traffic-Simulator/2.0" \
            --log=/dev/null \
            --quiet \
            "$TARGET_URL POST < /tmp/siege_post_data.json" \
            >> "$LOG_FILE" 2>&1 &
    else
        # GET flood
        siege \
            --concurrent=$concurrent \
            --time=999H \
            --delay=$SIEGE_DELAY \
            --timeout=$SIEGE_TIMEOUT \
            --header="User-Agent: Siege-Traffic-Simulator/2.0" \
            --log=/dev/null \
            --quiet \
            --file=/tmp/siege_urls.txt \
            >> "$LOG_FILE" 2>&1 &
    fi
    
    SIEGE_PID=$!
    
    if [ -n "$SIEGE_PID" ] && kill -0 "$SIEGE_PID" 2>/dev/null; then
        log "Siege started successfully (PID: $SIEGE_PID)"
        return 0
    else
        log "ERROR: Failed to start Siege"
        return 1
    fi
}

# Restart siege với concurrent users mới
restart_siege_with_new_concurrent() {
    local new_concurrent=$1
    
    # Kill old siege
    if [ -n "$SIEGE_PID" ] && kill -0 "$SIEGE_PID" 2>/dev/null; then
        kill -TERM "$SIEGE_PID" 2>/dev/null
        sleep 1
        kill -KILL "$SIEGE_PID" 2>/dev/null || true
    fi
    
    pkill -9 siege 2>/dev/null || true
    sleep 1
    
    # Start new siege
    start_siege_flood "$new_concurrent" "$FLOOD_TYPE"
}

# Main pattern generation với Python
generate_compressed_pattern_python() {
    local duration_seconds=$1
    
    log "=== PYTHON-ENHANCED SIEGE FLOOD SIMULATION ==="
    log "Target: $TARGET_URL"
    log "Flood Type: $FLOOD_TYPE"
    log "Math Engine: Python3"
    log "Compression: ${TIME_COMPRESSION}x"
    log "Real duration: ${duration_seconds}s = Virtual: $(python3 -c "print(f'{$duration_seconds * $TIME_COMPRESSION / 3600:.1f}')")h"
    
    if ! init_tc_qdisc; then
        log "ERROR: Cannot initialize TC qdisc"
        return 1
    fi
    
    # Start initial siege
    local initial_concurrent=50
    if ! start_siege_flood "$initial_concurrent" "$FLOOD_TYPE"; then
        log "ERROR: Cannot start Siege"
        return 1
    fi
    
    local update_interval=5
    local current_time=0
    local last_concurrent=0
    local restart_threshold=20  # Restart siege if change > 20%
    
    while [ $current_time -lt $duration_seconds ]; do
        local python_output
        if python_output=$(python3 /tmp/traffic_calculator.py compressed $current_time $TIME_COMPRESSION 2>/dev/null); then
            local concurrent=$(echo "$python_output" | awk '{print $1}')
            local virtual_hour=$(echo "$python_output" | awk '{print $2}')
            local virtual_day=$(echo "$python_output" | awk '{print $3}')
            local virtual_minute=$(echo "$python_output" | awk '{print $4}')
            
            local bandwidth=$(concurrent_to_bandwidth "$concurrent")
            
            # Check if need to restart siege
            local change_percent=0
            if [ $last_concurrent -gt 0 ]; then
                change_percent=$(echo "scale=0; ($concurrent - $last_concurrent) * 100 / $last_concurrent" | bc -l | tr -d '-')
            fi
            
            if [ $last_concurrent -eq 0 ] || [ $change_percent -gt $restart_threshold ]; then
                restart_siege_with_new_concurrent "$concurrent"
                log "T+${current_time}s | Virtual: Day${virtual_day} ${virtual_hour}:$(printf "%02d" $virtual_minute) | Concurrent: ${concurrent} | BW: ${bandwidth} [RESTARTED]"
            else
                log "T+${current_time}s | Virtual: Day${virtual_day} ${virtual_hour}:$(printf "%02d" $virtual_minute) | Concurrent: ${concurrent} | BW: ${bandwidth} [PYTHON]"
            fi
            
            update_tc_rate "$bandwidth"
            last_concurrent=$concurrent
            
        else
            log "T+${current_time}s | ERROR: Python calculation failed"
        fi
        
        sleep $update_interval
        current_time=$((current_time + update_interval))
    done
}

# Yo-yo pattern với Python
generate_yoyo_pattern_python() {
    local duration_seconds=$1
    local yoyo_type="${2:-square}"
    
    log "=== PYTHON-ENHANCED YO-YO PATTERN ==="
    log "Type: $yoyo_type | Duration: ${duration_seconds}s"
    log "Flood Type: $FLOOD_TYPE"
    
    if ! init_tc_qdisc; then
        log "ERROR: Cannot initialize TC qdisc"
        return 1
    fi
    
    local initial_concurrent=50
    if ! start_siege_flood "$initial_concurrent" "$FLOOD_TYPE"; then
        log "ERROR: Cannot start Siege"
        return 1
    fi
    
    local update_interval=3
    local current_time=0
    local last_concurrent=0
    
    while [ $current_time -lt $duration_seconds ]; do
        local python_output
        if python_output=$(python3 /tmp/traffic_calculator.py yoyo $current_time $yoyo_type 2>/dev/null); then
            local concurrent=$(echo "$python_output" | awk '{print $1}')
            local cycle_pos=$(echo "$python_output" | awk '{print $2}')
            
            local bandwidth=$(concurrent_to_bandwidth "$concurrent")
            
            # Restart if significant change
            if [ $(echo "($concurrent - $last_concurrent) * ($concurrent - $last_concurrent) > 400" | bc -l) -eq 1 ]; then
                restart_siege_with_new_concurrent "$concurrent"
                log "T+${current_time}s | Cycle: ${cycle_pos} | Concurrent: ${concurrent} | BW: ${bandwidth} [$yoyo_type-RESTART]"
            else
                log "T+${current_time}s | Cycle: ${cycle_pos} | Concurrent: ${concurrent} | BW: ${bandwidth} [$yoyo_type]"
            fi
            
            update_tc_rate "$bandwidth"
            last_concurrent=$concurrent
        fi
        
        sleep $update_interval
        current_time=$((current_time + update_interval))
    done
}

# Check dependencies
check_dependencies() {
    local missing_deps=()
    
    if ! command -v siege &> /dev/null; then
        missing_deps+=("siege")
    fi
    
    if ! command -v bc &> /dev/null; then
        missing_deps+=("bc")
    fi
    
    if ! command -v tc &> /dev/null; then
        missing_deps+=("iproute2")
    fi
    
    if [[ $EUID -ne 0 ]]; then
        log "ERROR: Root privileges required"
        exit 1
    fi
    
    if [ ${#missing_deps[@]} -gt 0 ]; then
        log "ERROR: Missing dependencies: ${missing_deps[*]}"
        log "Install: sudo apt-get install ${missing_deps[*]}"
        exit 1
    fi
    
    if ! ip link show "$INTERFACE" &>/dev/null; then
        log "ERROR: Interface $INTERFACE does not exist"
        exit 1
    fi
}

# Usage
show_usage() {
    cat << EOF
╔══════════════════════════════════════════════════════════════════════════════╗
║              SIEGE HTTP FLOOD TRAFFIC SIMULATOR WITH PYTHON                  ║
║              Advanced HTTP GET/POST Load Testing & Traffic Control           ║
╚══════════════════════════════════════════════════════════════════════════════╝

USAGE:
   $0 [TARGET_URL] [INTERFACE] [DURATION] [COMPRESSION] [FLOOD_TYPE] [MODE] [YOYO_TYPE]

PARAMETERS:
   TARGET_URL    : Target URL (default: http://localhost:3000)
   INTERFACE     : Network interface (default: eth0)
   DURATION      : Test duration in seconds (default: 300)
   COMPRESSION   : Time compression factor (default: 72x)
   FLOOD_TYPE    : GET or POST (default: GET)
   MODE          : Traffic pattern mode
   YOYO_TYPE     : Yo-yo pattern type (for yoyo mode)

FLOOD TYPES:
   GET          - HTTP GET flood
                  ✓ Simple request pattern
                  ✓ Minimal bandwidth usage
                  ✓ Ideal for endpoint testing
                  
   POST         - HTTP POST flood with JSON payload
                  ✓ JSON data submission
                  ✓ Higher bandwidth usage
                  ✓ Database/API stress testing

AVAILABLE MODES:
   python-compressed  - Compressed time simulation with Python
                       ✓ Realistic daily/weekly traffic patterns
                       ✓ Automatic concurrent user scaling
                       ✓ TC qdisc bandwidth control
                       ✓ Update interval: 5 seconds
                       
   python-yoyo       - Yo-yo pattern simulation
                       ✓ Rapid load variations
                       ✓ Stress testing scenarios
                       ✓ Update interval: 3 seconds

YOYO PATTERN TYPES:
   square      - Abrupt high/low transitions
                 └─ High: 200 concurrent, Low: 20 concurrent
                 
   sawtooth    - Gradual ramp then sudden drop
                 └─ Linear 20→200 concurrent, then drop
                 
   burst       - Intensive bursts with cooldown
                 └─ Burst: 300, Medium: 150, Idle: 30
                 
   wave        - Sinusoidal wave pattern
                 └─ Smooth 20→180→20 concurrent oscillation

ENVIRONMENT VARIABLES:
   SIEGE_CONCURRENT  - Initial concurrent users (default: 50)
   SIEGE_DELAY       - Delay between requests (default: 0)
   SIEGE_TIMEOUT     - Request timeout in seconds (default: 5)

EXAMPLES:
   # Basic GET flood test (compressed time)
   sudo $0 http://192.168.1.100:3000 eth0 300 72 GET python-compressed
   
   # POST flood test to API endpoint
   sudo $0 http://api.example.com/data eth0 180 1 POST python-compressed
   
   # Square wave yo-yo GET pattern
   sudo $0 http://test.local:8080 wlan0 120 1 GET python-yoyo square
   
   # Burst POST pattern for stress test
   sudo $0 http://10.0.0.1/api eth1 300 1 POST python-yoyo burst
   
   # Custom concurrent users
   sudo SIEGE_CONCURRENT=100 $0 http://localhost:3000 eth0 600 72 GET python-compressed

ARCHITECTURE:
   ┌──────────────┐    ┌──────────────┐    ┌──────────────┐
   │   Python     │───▶│   Traffic    │───▶│  TC Qdisc    │
   │   Math       │    │   Pattern    │    │  Bandwidth   │
   │   Engine     │    │              │    │   Control    │
   └──────────────┘    └──────────────┘    └──────────────┘
           │                   │                    │
           └───────────────────┴────────────────────┘
                               │
                    ┌──────────▼──────────┐
                    │   Siege HTTP Flood   │
                    │  (Dynamic Restart)   │
                    └─────────────────────┘

KEY FEATURES:
   ✓ Dynamic concurrent user scaling based on traffic patterns
   ✓ Automatic Siege restart when significant load changes
   ✓ TC qdisc bandwidth throttling
   ✓ Real-time traffic monitoring
   ✓ GET and POST flood support
   ✓ Python-powered mathematical accuracy
   ✓ Compressed time simulation (weeks in minutes)
   ✓ Multiple yo-yo patterns for stress testing

SYSTEM REQUIREMENTS:
   REQUIRED:
   - Root privileges (sudo)
   - siege package
   - iproute2 package (tc command)
   - bc calculator
   - Python3 with math module
   
   NETWORK:
   - Valid network interface
   - Target URL should be accessible
   - Sufficient bandwidth

MONITORING:
   - Logs: siege_traffic_YYYYMMDD_HHMMSS.log
   - Real-time status with timestamps
   - Virtual time tracking (compressed mode)
   - Concurrent user changes logged
   - TC qdisc rate changes tracked

IMPORTANT WARNINGS:
   ⚠ This tool generates HTTP flood traffic
   ⚠ Use only on authorized test environments
   ⚠ Monitor target system resources
   ⚠ May impact network performance
   ⚠ Ensure target can handle the load

TROUBLESHOOTING:
   - "siege not found" → sudo apt-get install siege
   - "Permission denied" → Run with sudo
   - "Connection refused" → Check target URL and port
   - "Interface error" → Verify interface name

VERSION: Siege Traffic Simulator v2.0 (Python-Enhanced)

EOF
}

# Main function
main() {
    local mode="${6:-python-compressed}"
    local yoyo_type="${7:-square}"
    
    log "=== SIEGE HTTP FLOOD TRAFFIC SIMULATOR ==="
    log "Target URL: $TARGET_URL"
    log "Interface: $INTERFACE"
    log "Duration: ${DURATION}s"
    log "Compression: ${TIME_COMPRESSION}x"
    log "Flood Type: $FLOOD_TYPE"
    log "Mode: $mode"
    
    check_dependencies
    check_python
    
    if [ "$PYTHON_AVAILABLE" = false ]; then
        log "ERROR: Python3 is required for this simulator"
        exit 1
    fi
    
    create_python_calculator
    log "Python calculator created"
    
    # Test target connectivity
    if command -v curl &>/dev/null; then
        if curl -s --max-time 3 "$TARGET_URL" &>/dev/null; then
            log "Target URL is reachable"
        else
            log "WARNING: Target URL may not be reachable"
        fi
    fi
    
    case "$mode" in
        "python-compressed")
            generate_compressed_pattern_python "$DURATION"
            ;;
        "python-yoyo")
            generate_yoyo_pattern_python "$DURATION" "$yoyo_type"
            ;;
        *)
            log "ERROR: Unknown mode: $mode"
            show_usage
            exit 1
            ;;
    esac
    
    log "=== SIMULATION COMPLETED ==="
    log "Log file: $LOG_FILE"
}

# Command line handling
if [[ "$1" == "-h" || "$1" == "--help" || "$1" == "help" ]]; then
    show_usage
    exit 0
fi

main "$@"
