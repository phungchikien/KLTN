#!/bin/bash

# =================================================================
# SIEGE HTTP GET FLOOD SIMULATOR WITH PYTHON MATH ENGINE
# =================================================================
# Converted from hping3 SYN flood to Siege HTTP GET flood
# Sử dụng Python để tính toán các hàm toán học phức tạp
# Dynamic concurrency control với mathematical accuracy

# Cấu hình mặc định
TARGET_URL="${1:-http://example.com}"
DURATION="${2:-300}"
TIME_COMPRESSION="${3:-72}"
LOG_FILE="siege_http_flood_$(date +%Y%m%d_%H%M%S).log"
VERBOSE=true

# Cấu hình Siege
MIN_CONCURRENT=1
MAX_CONCURRENT=500
BASE_CONCURRENT=10
SIEGE_RC_FILE="/tmp/siege_custom_$(date +%s).rc"

# PID và flags
declare -a SIEGE_PIDS=()
PYTHON_AVAILABLE=false
SIEGE_ACTIVE=false

# Hàm logging
log() {
    local message="$1"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo "[$timestamp] $message" | tee -a "$LOG_FILE"
}

# Hàm cleanup
cleanup() {
    log "=== CLEANUP STARTED ==="
    
    # Kill all Siege processes
    for pid in "${SIEGE_PIDS[@]}"; do
        if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
            log "Killing siege process (PID: $pid)"
            kill -TERM "$pid" 2>/dev/null
            sleep 1
            if kill -0 "$pid" 2>/dev/null; then
                kill -KILL "$pid" 2>/dev/null
            fi
        fi
    done
    
    # Failsafe: kill all siege processes
    if pgrep -x siege > /dev/null 2>&1; then
        log "WARNING: Found orphaned siege processes, killing all..."
        pkill -9 siege 2>/dev/null
    fi
    
    # Remove custom Siege RC file
    rm -f "$SIEGE_RC_FILE"
    rm -f /tmp/traffic_calculator.py
    
    log "=== CLEANUP COMPLETED ==="
    exit 0
}

trap cleanup EXIT INT TERM

# Kiểm tra Python availability
check_python() {
    if command -v python3 &> /dev/null; then
        if python3 -c "import math; print('Python math OK')" &>/dev/null; then
            PYTHON_AVAILABLE=true
            log "Python3 with math module: Available"
            return 0
        fi
    fi
    
    if command -v python &> /dev/null; then
        if python -c "import math; print('Python math OK')" &>/dev/null; then
            PYTHON_AVAILABLE=true
            log "Python with math module: Available"
            return 0
        fi
    fi
    
    log "WARNING: Python not available, falling back to simplified math"
    PYTHON_AVAILABLE=false
    return 1
}

# Python script để tính toán traffic patterns
create_python_calculator() {
    cat << 'PYTHON_SCRIPT' > /tmp/traffic_calculator.py
#!/usr/bin/env python3
import math
import sys
import os

# Read scale factor from environment
SCALE_FACTOR = int(os.environ.get('TRAFFIC_SCALE_FACTOR', '10'))

def calculate_hourly_rate(hour, scale_factor=SCALE_FACTOR):
    """
    Tính toán concurrent users theo giờ với các peak patterns
    """
    # Morning peak (9 AM) - Gaussian distribution
    morning_peak = 25 * math.exp(-((hour - 9) ** 2) / 6.25)
    
    # Evening peak (8 PM) - Gaussian distribution  
    evening_peak = 45 * math.exp(-((hour - 20) ** 2) / 7.84)
    
    # Night drop (2:30 AM) - Negative Gaussian
    night_drop = -15 * math.exp(-((hour - 2.5) ** 2) / 3.24)
    
    # Daily sine wave cycle
    daily_cycle = 5 * math.sin(math.pi * hour / 12 - math.pi/2)
    
    # Base traffic level
    base_level = 20
    
    # Combine all factors
    traffic_factor = base_level + morning_peak + evening_peak + night_drop + daily_cycle
    
    # Calculate concurrent users with minimum threshold
    concurrent = max(10, traffic_factor * scale_factor)
    
    return int(concurrent)

def calculate_weekly_multiplier(day_of_week):
    """
    Tính toán hệ số nhân theo ngày trong tuần
    """
    base = 87
    
    # Weekly sine pattern
    sine_component = 8 * math.sin(2 * math.pi * day_of_week / 7 + math.pi/7)
    
    # Weekend spike (Saturday = day 6)
    weekend_spike = 5 * math.exp(-((day_of_week - 6) ** 2) / 2.25)
    
    # Combine factors
    weekly_factor = (base + sine_component + weekend_spike) / base
    
    return weekly_factor

def calculate_minute_factor(minute_in_hour):
    """
    Tính toán biến động theo phút trong giờ
    """
    return 1 + 0.3 * math.sin(2 * math.pi * minute_in_hour / 60)

def get_compressed_time(elapsed_seconds, compression_factor):
    """
    Tính toán thời gian ảo với compression factor
    """
    virtual_hours = elapsed_seconds * compression_factor / 3600
    current_hour = int(virtual_hours % 24)
    
    virtual_days = virtual_hours / 24
    day_of_week = int(virtual_days % 7) + 1
    
    seconds_in_hour = (elapsed_seconds * compression_factor) % 3600
    minute_in_hour = int(seconds_in_hour / 60)
    
    return current_hour, day_of_week, minute_in_hour

def calculate_concurrent_users(elapsed_seconds, compression_factor, noise_factor=0.15):
    """
    Tính toán số concurrent users với tất cả các yếu tố
    """
    try:
        # Get virtual time components
        hour, day, minute = get_compressed_time(elapsed_seconds, compression_factor)
        
        # Calculate base rates
        hourly_rate = calculate_hourly_rate(hour)
        weekly_multiplier = calculate_weekly_multiplier(day)
        minute_factor = calculate_minute_factor(minute)
        
        # Combine all factors
        base_concurrent = hourly_rate * weekly_multiplier * minute_factor
        
        # Add random noise
        import random
        noise = random.uniform(-noise_factor, noise_factor)
        final_concurrent = base_concurrent * (1 + noise)
        
        return max(1, int(final_concurrent)), hour, day, minute
    except Exception as e:
        print(f"ERROR: {e}", file=sys.stderr)
        sys.exit(1)

def calculate_yoyo_concurrent(elapsed_seconds, cycle_duration=20, yoyo_type="square"):
    """
    Tính toán yo-yo pattern concurrent users
    """
    cycle_position = (elapsed_seconds % cycle_duration) / cycle_duration
    
    if yoyo_type == "square":
        return 200 if cycle_position < 0.5 else 20
    elif yoyo_type == "sawtooth":
        if cycle_position < 0.8:
            return int(20 + 380 * cycle_position / 0.8)
        else:
            return 20
    elif yoyo_type == "burst":
        if cycle_position < 0.1:
            return 500
        elif cycle_position < 0.2:
            return 200
        else:
            return 50
    else:
        return 100

if __name__ == "__main__":
    if len(sys.argv) < 3:
        print("Usage: python3 traffic_calculator.py <mode> <elapsed_seconds> [compression_factor] [yoyo_type]", file=sys.stderr)
        sys.exit(1)
    
    try:
        mode = sys.argv[1]
        elapsed_seconds = float(sys.argv[2])
        
        if mode == "compressed":
            compression_factor = float(sys.argv[3]) if len(sys.argv) > 3 else 72
            concurrent, hour, day, minute = calculate_concurrent_users(elapsed_seconds, compression_factor)
            print(f"{concurrent} {hour} {day} {minute}")
        
        elif mode == "yoyo":
            yoyo_type = sys.argv[3] if len(sys.argv) > 3 else "square"
            concurrent = calculate_yoyo_concurrent(elapsed_seconds, yoyo_type=yoyo_type)
            cycle_pos = (elapsed_seconds % 20) / 20
            print(f"{concurrent} {cycle_pos:.2f}")
        
        else:
            print(f"ERROR: Unknown mode: {mode}", file=sys.stderr)
            sys.exit(1)
    except Exception as e:
        print(f"ERROR: {e}", file=sys.stderr)
        sys.exit(1)
PYTHON_SCRIPT
    
    chmod +x /tmp/traffic_calculator.py
}

# Fallback math functions
calculate_simple_concurrent() {
    local hour=$1
    local day=$2
    local minute=$3
    
    # Simplified pattern using only bc capabilities
    local base_concurrent=50
    
    # Simple hour-based variation
    if [ $hour -ge 8 ] && [ $hour -le 10 ]; then
        base_concurrent=150  # Morning peak
    elif [ $hour -ge 19 ] && [ $hour -le 21 ]; then
        base_concurrent=250  # Evening peak
    elif [ $hour -ge 1 ] && [ $hour -le 5 ]; then
        base_concurrent=20   # Night low
    fi
    
    # Weekend multiplier
    if [ $day -eq 6 ] || [ $day -eq 7 ]; then
        base_concurrent=$(echo "scale=0; $base_concurrent * 1.3 / 1" | bc -l)
    fi
    
    # Add some variation based on minute
    local minute_var=$(echo "scale=0; $minute % 10" | bc -l)
    local variation=$(echo "scale=0; $base_concurrent * $minute_var / 100" | bc -l)
    
    local final_concurrent=$(echo "scale=0; $base_concurrent + $variation" | bc -l)
    
    # Clamp values
    if [ $final_concurrent -lt $MIN_CONCURRENT ]; then
        final_concurrent=$MIN_CONCURRENT
    elif [ $final_concurrent -gt $MAX_CONCURRENT ]; then
        final_concurrent=$MAX_CONCURRENT
    fi
    
    echo "$final_concurrent"
}

# Create custom Siege RC file
create_siege_rc() {
    cat > "$SIEGE_RC_FILE" << EOF
# Custom Siege Configuration for HTTP Flood Simulation
verbose = false
color = off
quiet = true
show-logfile = false
logging = true
protocol = HTTP/1.1
chunked = true
cache = false
connection = close
concurrent = $BASE_CONCURRENT
time = ${DURATION}S
delay = 0
timeout = 30
failures = 1024
internet = false
benchmark = true
user-agent = Mozilla/5.0 (compatible; SiegeLoadTester/1.0)
accept-encoding = gzip, deflate
url-escaping = true
EOF

    log "Custom Siege RC created: $SIEGE_RC_FILE"
}

# Validate concurrent value
validate_concurrent() {
    local concurrent=$1
    
    if [ $concurrent -lt $MIN_CONCURRENT ]; then
        concurrent=$MIN_CONCURRENT
    elif [ $concurrent -gt $MAX_CONCURRENT ]; then
        concurrent=$MAX_CONCURRENT
    fi
    
    echo $concurrent
}

# Start Siege with specific concurrency
start_siege() {
    local concurrent=$1
    
    # Validate
    concurrent=$(validate_concurrent $concurrent)
    
    log "Starting Siege with $concurrent concurrent users"
    
    # Start Siege in background
    siege \
        -R "$SIEGE_RC_FILE" \
        -c "$concurrent" \
        -b \
        "$TARGET_URL" \
        >> "$LOG_FILE" 2>&1 &
    
    local pid=$!
    SIEGE_PIDS+=("$pid")
    
    # Verify process started
    sleep 1
    if kill -0 "$pid" 2>/dev/null; then
        SIEGE_ACTIVE=true
        log "Siege started successfully (PID: $pid, Concurrent: $concurrent)"
        return 0
    else
        log "ERROR: Failed to start Siege"
        return 1
    fi
}

# Update Siege concurrency dynamically
update_siege_concurrency() {
    local new_concurrent=$1
    
    # Validate
    new_concurrent=$(validate_concurrent $new_concurrent)
    
    # Kill current Siege processes
    for pid in "${SIEGE_PIDS[@]}"; do
        if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
            kill -TERM "$pid" 2>/dev/null
        fi
    done
    
    # Clear PID array
    SIEGE_PIDS=()
    
    # Wait a bit
    sleep 0.5
    
    # Start new Siege with updated concurrency
    start_siege "$new_concurrent"
}

# Main pattern generation với Python support
generate_compressed_pattern_python() {
    local duration_seconds=$1
    
    log "=== PYTHON-ENHANCED SIEGE HTTP FLOOD SIMULATION ==="
    log "Math Engine: Python3 with accurate mathematical functions"
    log "Compression factor: ${TIME_COMPRESSION}x"
    log "Real duration: ${duration_seconds}s = Virtual: $(python3 -c "print(f'{$duration_seconds * $TIME_COMPRESSION / 3600:.1f}')" 2>/dev/null || echo "N/A")h"
    log "Target URL: $TARGET_URL"
    
    # Create Siege RC
    create_siege_rc
    
    # Start initial Siege
    if ! start_siege $BASE_CONCURRENT; then
        log "ERROR: Cannot start Siege"
        return 1
    fi
    
    # Calculate update interval based on compression
    local update_interval=5
    if [ $TIME_COMPRESSION -gt 100 ]; then
        update_interval=3
    elif [ $TIME_COMPRESSION -lt 10 ]; then
        update_interval=10
    fi
    
    log "Update interval: ${update_interval}s"
    
    local current_time=0
    local last_concurrent=""
    
    while [ $current_time -lt $duration_seconds ]; do
        local python_output
        if python_output=$(TRAFFIC_SCALE_FACTOR=10 python3 /tmp/traffic_calculator.py compressed $current_time $TIME_COMPRESSION 2>/dev/null); then
            # Parse Python output: "concurrent hour day minute"
            local concurrent=$(echo "$python_output" | awk '{print $1}')
            local virtual_hour=$(echo "$python_output" | awk '{print $2}')
            local virtual_day=$(echo "$python_output" | awk '{print $3}')
            local virtual_minute=$(echo "$python_output" | awk '{print $4}')
            
            # Validate concurrent
            concurrent=$(validate_concurrent $concurrent)
            
            if [ "$concurrent" != "$last_concurrent" ]; then
                update_siege_concurrency "$concurrent"
                log "T+${current_time}s | Virtual: Day${virtual_day} ${virtual_hour}:$(printf "%02d" $virtual_minute) | Concurrent: ${concurrent} users [PYTHON]"
                last_concurrent="$concurrent"
            elif [ "$VERBOSE" = true ]; then
                log "T+${current_time}s | Virtual: Day${virtual_day} ${virtual_hour}:$(printf "%02d" $virtual_minute) | Concurrent: ${concurrent} users [unchanged]"
            fi
        else
            log "T+${current_time}s | ERROR: Python calculation failed, using fallback"
            
            # Fallback to simple calculation
            local hour=$(echo "scale=0; ($current_time * $TIME_COMPRESSION / 3600) % 24" | bc -l)
            local day=$(echo "scale=0; ($current_time * $TIME_COMPRESSION / 86400) % 7 + 1" | bc -l)
            local minute=$(echo "scale=0; ($current_time * $TIME_COMPRESSION % 3600) / 60" | bc -l)
            
            local simple_concurrent=$(calculate_simple_concurrent $hour $day $minute)
            
            update_siege_concurrency "$simple_concurrent"
            log "T+${current_time}s | Virtual: Day${day} ${hour}:$(printf "%02d" $minute) | Concurrent: ${simple_concurrent} users [FALLBACK]"
        fi
        
        sleep $update_interval
        current_time=$((current_time + update_interval))
    done
}

# Yo-yo pattern with Python
generate_yoyo_pattern_python() {
    local duration_seconds=$1
    local yoyo_type="${2:-square}"
    
    log "=== PYTHON-ENHANCED YO-YO PATTERN (SIEGE) ==="
    log "Type: $yoyo_type | Duration: ${duration_seconds}s"
    log "Target URL: $TARGET_URL"
    
    # Create Siege RC
    create_siege_rc
    
    # Start initial Siege
    if ! start_siege $BASE_CONCURRENT; then
        log "ERROR: Cannot start Siege"
        return 1
    fi
    
    local update_interval=5
    local current_time=0
    
    while [ $current_time -lt $duration_seconds ]; do
        local python_output
        if python_output=$(python3 /tmp/traffic_calculator.py yoyo $current_time $yoyo_type 2>/dev/null); then
            local concurrent=$(echo "$python_output" | awk '{print $1}')
            local cycle_pos=$(echo "$python_output" | awk '{print $2}')
            
            # Validate concurrent
            concurrent=$(validate_concurrent $concurrent)
            
            update_siege_concurrency "$concurrent"
            log "T+${current_time}s | Cycle: ${cycle_pos} | Concurrent: ${concurrent} users [$yoyo_type-PYTHON]"
        else
            log "T+${current_time}s | ERROR: Python yo-yo calculation failed"
        fi
        
        sleep $update_interval
        current_time=$((current_time + update_interval))
    done
}

# Dependencies check
check_dependencies() {
    local missing_deps=()
    
    if ! command -v siege &> /dev/null; then
        missing_deps+=("siege")
    fi
    
    if ! command -v bc &> /dev/null; then
        missing_deps+=("bc")
    fi
    
    if [ ${#missing_deps[@]} -gt 0 ]; then
        log "ERROR: Missing dependencies: ${missing_deps[*]}"
        log "Install with: sudo apt install ${missing_deps[*]}"
        exit 1
    fi
    
    # Test URL accessibility
    if ! curl -s -o /dev/null -w "%{http_code}" --max-time 5 "$TARGET_URL" &>/dev/null; then
        log "WARNING: Target URL may not be reachable: $TARGET_URL"
    fi
}

# Validate URL format
validate_url() {
    local url=$1
    
    if [[ ! "$url" =~ ^https?:// ]]; then
        log "ERROR: Invalid URL format. Must start with http:// or https://"
        log "Example: http://example.com or https://example.com"
        exit 1
    fi
}

# Show usage
show_usage() {
    cat << EOF
╔══════════════════════════════════════════════════════════════════════════════╗
║              SIEGE HTTP GET FLOOD SIMULATOR WITH PYTHON                      ║
║              Python-Enhanced Concurrent Users Pattern Generator              ║
╚══════════════════════════════════════════════════════════════════════════════╝

USAGE:
   $0 [TARGET_URL] [DURATION] [COMPRESSION] [MODE] [YOYO_TYPE]

PARAMETERS:
   TARGET_URL    : Target URL (default: http://example.com)
                   Must include http:// or https://
   DURATION      : Test duration in seconds (default: 300)
   COMPRESSION   : Time compression factor (default: 72x)
   MODE          : Traffic pattern mode (see below)
   YOYO_TYPE     : Yo-yo pattern type (for python-yoyo mode only)

AVAILABLE MODES:
   python-compressed  - Compressed time simulation with Python math engine
                       ✓ Dynamic concurrent users adjustment
                       ✓ Realistic daily/weekly traffic patterns
                       ✓ Update interval: 5 seconds (adaptive)
                       
   python-yoyo       - Yo-yo pattern simulation with Python engine  
                       ✓ Rapid concurrent users switching
                       ✓ Stress testing auto-scaling
                       ✓ Update interval: 5 seconds

YOYO PATTERN TYPES:
   square      - Square wave (High: 200, Low: 20 concurrent users)
   sawtooth    - Gradual ramp up (20→400 users, then drop)
   burst       - Short bursts (500 peak, 50 idle)

SIEGE CONFIGURATION:
   Min Concurrent:    $MIN_CONCURRENT users
   Max Concurrent:    $MAX_CONCURRENT users
   Base Concurrent:   $BASE_CONCURRENT users
   Benchmark Mode:    Enabled (no delays)
   Connection:        Close (new connection per request)
   Protocol:          HTTP/1.1

EXAMPLES:
   # Basic compressed time simulation
   $0 http://192.168.1.100 300 72 python-compressed
   
   # HTTPS target with square wave pattern
   $0 https://example.com 180 1 python-yoyo square
   
   # Long simulation (2 weeks in 10 minutes)
   $0 http://api.example.com 600 144 python-compressed
   
   # Burst pattern stress test
   $0 http://loadbalancer.local 120 1 python-yoyo burst

TRAFFIC PATTERNS:
   
   COMPRESSED MODE:
   - Simulates realistic user behavior over time
   - Morning peak (~9 AM): 150-200 concurrent users
   - Evening peak (~8 PM): 250-350 concurrent users
   - Night dip (~2:30 AM): 20-50 concurrent users
   - Weekend spike: +30% users
   
   YOYO MODES:
   - Square: Instant switching for failover testing
   - Sawtooth: Gradual scaling for auto-scaling verification
   - Burst: Short peaks for capacity planning

MONITORING:
   - All activity logged to: siege_http_flood_YYYYMMDD_HHMMSS.log
   - Real-time concurrent users adjustments
   - Virtual time tracking (compressed mode)
   - Siege statistics in log file

SYSTEM REQUIREMENTS:
   - siege package (sudo apt install siege)
   - bc calculator
   - Python3 with math module (recommended)
   - Network connectivity to target

IMPORTANT WARNINGS:
   ⚠ This tool generates significant HTTP GET traffic
   ⚠ Use only on authorized test systems
   ⚠ Monitor server resources during execution
   ⚠ Respect rate limits and server capacity
   ⚠ Stop immediately if issues detected

COMPARISON TO HPING3 VERSION:
   SYN Flood (Layer 4)          →  HTTP GET Flood (Layer 7)
   Packets per second           →  Concurrent HTTP users
   TC qdisc bandwidth control   →  Siege concurrency control
   Raw TCP SYN packets          →  Complete HTTP GET requests
   Network layer stress         →  Application layer stress

VERSION INFO:
   Siege HTTP Flood Simulator v1.0
   Converted from hping3 SYN flood architecture
   
EOF
}

# Main function
main() {
    local mode="${4:-python-compressed}"
    local yoyo_type="${5:-square}"
    
    log "=== SIEGE HTTP GET FLOOD SIMULATOR ==="
    log "Target URL: $TARGET_URL"
    log "Duration: ${DURATION}s"
    log "Compression: ${TIME_COMPRESSION}x"
    log "Mode: $mode"
    
    # Validate URL
    validate_url "$TARGET_URL"
    
    # Check dependencies
    check_dependencies
    check_python
    
    # Create Python calculator
    if [ "$PYTHON_AVAILABLE" = true ]; then
        create_python_calculator
        log "Python math calculator created successfully"
    else
        log "Using simplified math fallback"
    fi
    
    # Execute pattern
    case "$mode" in
        "python-compressed")
            if [ "$PYTHON_AVAILABLE" = true ]; then
                generate_compressed_pattern_python "$DURATION"
            else
                log "ERROR: Python not available for compressed mode"
                exit 1
            fi
            ;;
        "python-yoyo")
            if [ "$PYTHON_AVAILABLE" = true ]; then
                generate_yoyo_pattern_python "$DURATION" "$yoyo_type"
            else
                log "ERROR: Python not available for yoyo mode"
                exit 1
            fi
            ;;
        *)
            log "ERROR: Unknown mode: $mode"
            log "Available modes: python-compressed, python-yoyo"
            show_usage
            exit 1
            ;;
    esac
    
    log "=== SIMULATION COMPLETED ==="
    log "Log file: $LOG_FILE"
}

# Command line handling
if [[ "$1" == "-h" || "$1" == "--help" || "$1" == "help" ]]; then
    show_usage
    exit 0
fi

main "$@"
