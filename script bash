#!/bin/bash

# =================================================================
# HPING3 TRAFFIC SIMULATOR - FIXED VERSION
# =================================================================
# Fixed syntax errors and improved error handling

# Cấu hình mặc định
TARGET_IP="${1:-8.8.8.8}"
INTERFACE="${2:-eth0}"
DURATION="${3:-300}"
TIME_COMPRESSION="${4:-72}"
LOG_FILE="hping3_traffic_tc_$(date +%Y%m%d_%H%M%S).log"
VERBOSE=true

# Cấu hình TC QDISC - FIXED CONSTRAINTS
PACKET_SIZE=60
BURST_SIZE="4m"         # FIXED: Increased to support high rates
LATENCY="200ms"
MIN_RATE="10kbit"
MAX_RATE="100mbit"      # Now properly supported by burst size

# PID tracking
HPING_PID=""
TC_ACTIVE=false

# Logging function
log() {
    local message="$1"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo "[$timestamp] $message" | tee -a "$LOG_FILE"
}

# Enhanced cleanup
cleanup() {
    log "=== CLEANUP STARTED ==="
    
    if [ -n "$HPING_PID" ] && kill -0 "$HPING_PID" 2>/dev/null; then
        log "Killing hping3 process (PID: $HPING_PID)"
        kill -TERM "$HPING_PID"
        sleep 2
        if kill -0 "$HPING_PID" 2>/dev/null; then
            kill -KILL "$HPING_PID"
        fi
        wait "$HPING_PID" 2>/dev/null
    fi
    
    if [ "$TC_ACTIVE" = true ]; then
        log "Removing tc qdisc from interface $INTERFACE"
        tc qdisc del dev "$INTERFACE" root 2>/dev/null || true
        TC_ACTIVE=false
    fi
    
    log "=== CLEANUP COMPLETED ==="
    exit 0
}

trap cleanup EXIT INT TERM

# FIXED: Time calculation functions
get_compressed_hour() {
    local elapsed_seconds=$1
    local compression_factor=$TIME_COMPRESSION
    
    local virtual_hours=$(echo "scale=6; $elapsed_seconds * $compression_factor / 3600" | bc -l 2>/dev/null)
    if [ -z "$virtual_hours" ]; then
        echo "0"
        return
    fi
    
    # FIXED: Proper rounding instead of truncation
    local current_hour=$(echo "scale=0; ($virtual_hours % 24) + 0.5" | bc -l 2>/dev/null | cut -d. -f1)
    if [ -z "$current_hour" ] || [ "$current_hour" -lt 0 ] || [ "$current_hour" -gt 23 ]; then
        current_hour=0
    fi
    
    echo "$current_hour"
}

# FIXED: Day calculation
get_compressed_day() {
    local elapsed_seconds=$1
    local compression_factor=$TIME_COMPRESSION
    
    local virtual_hours=$(echo "scale=6; $elapsed_seconds * $compression_factor / 3600" | bc -l 2>/dev/null)
    if [ -z "$virtual_hours" ]; then
        echo "1"
        return
    fi
    
    local virtual_days=$(echo "scale=6; $virtual_hours / 24" | bc -l 2>/dev/null)
    if [ -z "$virtual_days" ]; then
        echo "1"
        return
    fi
    
    # FIXED: Proper day of week calculation (1-7)
    local day_of_week=$(echo "scale=0; $virtual_days % 7" | bc -l 2>/dev/null)
    if [ -z "$day_of_week" ]; then
        day_of_week=1
    elif [ "$day_of_week" -eq 0 ]; then
        day_of_week=7
    fi
    
    echo "$day_of_week"
}

# FIXED: Traffic rate calculation with proper syntax
calculate_hourly_rate() {
    local hour=$1
    local scale_factor=200  # FIXED: Removed space around =
    
    # Enhanced error handling for bc calculations
    local morning_peak=$(echo "scale=6; 25 * e(-1 * (($hour - 9) ^ 2) / 6.25)" | bc -l 2>/dev/null) 
    local evening_peak=$(echo "scale=6; 45 * e(-1 * (($hour - 20) ^ 2) / 7.84)" | bc -l 2>/dev/null)
    local night_drop=$(echo "scale=6; -15 * e(-1 * (($hour - 2.5) ^ 2) / 3.24)" | bc -l 2>/dev/null)
    local daily_cycle=$(echo "scale=6; 5 * s(3.14159 * $hour / 12 - 3.14159/2)" | bc -l 2>/dev/null)
    local base_level=20
    
    # Validate bc results
    if [ -z "$morning_peak" ]; then morning_peak=0; fi
    if [ -z "$evening_peak" ]; then evening_peak=0; fi
    if [ -z "$night_drop" ]; then night_drop=0; fi
    if [ -z "$daily_cycle" ]; then daily_cycle=0; fi
    
    local traffic_factor=$(echo "scale=6; $base_level + $morning_peak + $evening_peak + $night_drop + $daily_cycle" | bc -l 2>/dev/null)
    
    if [ -z "$traffic_factor" ]; then
        log "ERROR: BC calculation failed for traffic_factor, using default"
        echo "800"
        return
    fi
    
    # FIXED: Added $ before scale_factor variable
    local pps=$(echo "scale=0; if($traffic_factor < 5) 800 else ($traffic_factor - 20) * $scale_factor" | bc -l 2>/dev/null)
    
    # Robust validation
    if [ -z "$pps" ] || ! [[ "$pps" =~ ^[0-9]+$ ]] || [ "$pps" -lt 1 ]; then
        log "WARNING: Invalid PPS calculation, using fallback value"
        pps=800
    fi
    
    echo "$pps"
}

# Enhanced weekly multiplier with error handling
calculate_weekly_multiplier() {
    local day_of_week=$1
    local base=87
    
    local sine_component=$(echo "scale=6; 8 * s(2 * 3.14159 * $day_of_week / 7 + 3.14159/7)" | bc -l 2>/dev/null)
    local weekend_spike=$(echo "scale=6; 5 * e(-1 * (($day_of_week - 6) ^ 2) / 2.25)" | bc -l 2>/dev/null)
    
    # Error handling
    if [ -z "$sine_component" ]; then sine_component=0; fi
    if [ -z "$weekend_spike" ]; then weekend_spike=0; fi
    
    local weekly_factor=$(echo "scale=6; ($base + $sine_component + $weekend_spike) / $base" | bc -l 2>/dev/null)
    
    # Ensure positive and reasonable multiplier
    if [ -z "$weekly_factor" ] || [ $(echo "$weekly_factor <= 0" | bc -l 2>/dev/null) -eq 1 ]; then
        weekly_factor="1.0"
    fi
    
    echo "$weekly_factor"
}

get_compressed_minute_in_hour() {
    local elapsed_seconds=$1
    local compression_factor=$TIME_COMPRESSION
    
    local virtual_seconds=$(echo "scale=6; $elapsed_seconds * $compression_factor" | bc -l 2>/dev/null)
    if [ -z "$virtual_seconds" ]; then
        echo "0"
        return
    fi
    
    local seconds_in_hour=$(echo "scale=0; $virtual_seconds % 3600" | bc -l 2>/dev/null)
    if [ -z "$seconds_in_hour" ]; then
        echo "0"
        return
    fi
    
    local minute_in_hour=$(echo "scale=0; $seconds_in_hour / 60" | bc -l 2>/dev/null)
    if [ -z "$minute_in_hour" ] || [ "$minute_in_hour" -lt 0 ] || [ "$minute_in_hour" -gt 59 ]; then
        minute_in_hour=0
    fi
    
    echo "$minute_in_hour"
}

# Enhanced bandwidth conversion with better error handling
pps_to_bandwidth() {
    local pps=$1
    local packet_size=$PACKET_SIZE
    
    if [ -z "$pps" ] || [ "$pps" -lt 1 ]; then
        echo "1kbit"
        return
    fi
    
    local bps=$(echo "scale=0; $pps * $packet_size * 8" | bc -l 2>/dev/null)
    
    if [ -z "$bps" ] || [ "$bps" -lt 1000 ]; then
        echo "1kbit"
        return
    fi
    
    # Handle large numbers more safely
    if [ $(echo "$bps >= 1000000000" | bc -l 2>/dev/null) -eq 1 ]; then
        local gbps=$(echo "scale=2; $bps / 1000000000" | bc -l 2>/dev/null)
        echo "${gbps}gbit"
    elif [ $(echo "$bps >= 1000000" | bc -l 2>/dev/null) -eq 1 ]; then
        local mbps=$(echo "scale=2; $bps / 1000000" | bc -l 2>/dev/null)
        echo "${mbps}mbit"
    elif [ $(echo "$bps >= 1000" | bc -l 2>/dev/null) -eq 1 ]; then
        local kbps=$(echo "scale=0; $bps / 1000" | bc -l 2>/dev/null)
        echo "${kbps}kbit"
    else
        echo "1kbit"
    fi
}

# TC qdisc functions remain the same but with enhanced logging
init_tc_qdisc() {
    log "Initializing TC qdisc on interface $INTERFACE"
    log "Configuration: rate=$MIN_RATE, burst=$BURST_SIZE, latency=$LATENCY"
    
    tc qdisc del dev "$INTERFACE" root 2>/dev/null || true
    
    if tc qdisc add dev "$INTERFACE" root tbf rate "$MIN_RATE" burst "$BURST_SIZE" latency "$LATENCY"; then
        TC_ACTIVE=true
        log "TC qdisc initialized successfully"
        log "Burst size $BURST_SIZE can handle rates up to $(echo "scale=0; 4*1000000*8/0.2/1000000" | bc -l)mbit"
        return 0
    else
        log "ERROR: Failed to initialize TC qdisc"
        return 1
    fi
}

update_tc_rate() {
    local new_rate="$1"
    
    if [ "$TC_ACTIVE" = true ]; then
        if tc qdisc change dev "$INTERFACE" root tbf rate "$new_rate" burst "$BURST_SIZE" latency "$LATENCY" 2>/dev/null; then
            return 0
        else
            log "WARNING: Failed to update TC rate to $new_rate, reinitializing..."
            tc qdisc del dev "$INTERFACE" root 2>/dev/null || true
            if tc qdisc add dev "$INTERFACE" root tbf rate "$new_rate" burst "$BURST_SIZE" latency "$LATENCY"; then
                return 0
            else
                log "ERROR: Failed to reinitialize TC qdisc"
                TC_ACTIVE=false
                return 1
            fi
        fi
    else
        return 1
    fi
}

start_hping3_flood() {
    log "Starting hping3 flood to $TARGET_IP"
    
    hping3 \
        -S \
        --flood \
        --rand-source \
        -p 80 \
        --interface "$INTERFACE" \
        "$TARGET_IP" \
        >> "$LOG_FILE" 2>&1 &
    
    HPING_PID=$!
    
    # Allow process to start
    sleep 0.2
    
    if [ -n "$HPING_PID" ] && kill -0 "$HPING_PID" 2>/dev/null; then
        log "hping3 started successfully (PID: $HPING_PID)"
        return 0
    else
        log "ERROR: Failed to start hping3"
        return 1
    fi
}

# ENHANCED: Main simulation with better error handling
generate_compressed_pattern_tc() {
    local duration_seconds=$1
    local compression_factor=$TIME_COMPRESSION
    
    log "=== FIXED TC QDISC SIMULATION ==="
    log "Compression factor: ${compression_factor}x"
    log "Real duration: ${duration_seconds}s = Virtual duration: $(echo "scale=1; $duration_seconds * $compression_factor / 3600" | bc -l) hours"
    log "Virtual speed: 1 real second = $(echo "scale=1; $compression_factor / 60" | bc -l) virtual minutes"
    log "Packet size: ${PACKET_SIZE} bytes"
    log "TC parameters: burst=$BURST_SIZE, latency=$LATENCY"
    log "FIXED: Proper burst size to handle high rates"
    
    if ! init_tc_qdisc; then
        log "ERROR: Cannot initialize TC qdisc"
        return 1
    fi
    
    if ! start_hping3_flood; then
        log "ERROR: Cannot start hping3 flood"
        return 1
    fi
    
    local update_interval=3
    local current_time=0
    local last_rate=""
    local error_count=0
    
    while [ $current_time -lt $duration_seconds ]; do
        # Get virtual time with error handling
        local virtual_hour=$(get_compressed_hour $current_time)
        local virtual_day=$(get_compressed_day $current_time)
        local virtual_minute=$(get_compressed_minute_in_hour $current_time)
        
        # Calculate rates with error handling
        local hourly_rate=$(calculate_hourly_rate $virtual_hour)
        local weekly_multiplier=$(calculate_weekly_multiplier $virtual_day)
        
        # Minute variation with error handling
        local minute_factor=$(echo "scale=6; 1 + 0.3 * s(2 * 3.14159 * $virtual_minute / 60)" | bc -l 2>/dev/null)
        if [ -z "$minute_factor" ]; then
            minute_factor="1.0"
        fi
        
        # Combine factors
        local base_rate=$(echo "scale=6; $hourly_rate * $weekly_multiplier * $minute_factor" | bc -l 2>/dev/null)
        if [ -z "$base_rate" ]; then
            log "WARNING: Rate calculation failed, using fallback"
            base_rate=1000
            error_count=$((error_count + 1))
        fi
        
        # Add noise
        local noise=$(echo "scale=6; (($RANDOM % 60) - 30) / 200" | bc -l 2>/dev/null)
        if [ -z "$noise" ]; then noise="0"; fi
        
        local final_rate_float=$(echo "scale=6; $base_rate * (1 + $noise)" | bc -l 2>/dev/null)
        if [ -z "$final_rate_float" ]; then
            final_rate_float=$base_rate
        fi
        
        local final_pps=$(echo "scale=0; if($final_rate_float < 1) 1 else ($final_rate_float + 0.5) / 1" | bc -l 2>/dev/null)
        
        # Robust validation
        if [ -z "$final_pps" ] || ! [[ "$final_pps" =~ ^[0-9]+$ ]] || [ "$final_pps" -lt 1 ]; then
            final_pps=1000
            error_count=$((error_count + 1))
        fi
        
        # Convert to bandwidth
        local bandwidth=$(pps_to_bandwidth "$final_pps")
        
        # Update TC rate
        if [ "$bandwidth" != "$last_rate" ]; then
            if update_tc_rate "$bandwidth"; then
                log "T+${current_time}s | Virtual: Day${virtual_day} ${virtual_hour}:$(printf "%02d" $virtual_minute) | PPS: ${final_pps} | BW: ${bandwidth}"
                last_rate="$bandwidth"
            else
                log "T+${current_time}s | ERROR: Failed to update TC rate to $bandwidth"
            fi
        else
            if [ "$VERBOSE" = true ]; then
                log "T+${current_time}s | Virtual: Day${virtual_day} ${virtual_hour}:$(printf "%02d" $virtual_minute) | PPS: ${final_pps} | BW: ${bandwidth} [unchanged]"
            fi
        fi
        
        # Error reporting
        if [ $((current_time % 30)) -eq 0 ] && [ "$error_count" -gt 0 ]; then
            log "WARNING: $error_count calculation errors detected in last 30s"
            error_count=0
        fi
        
        sleep $update_interval
        current_time=$((current_time + update_interval))
    done
}

check_dependencies() {
    local missing_deps=()
    
    if ! command -v hping3 &> /dev/null; then
        missing_deps+=("hping3")
    fi
    
    if ! command -v bc &> /dev/null; then
        missing_deps+=("bc")
    fi
    
    if ! command -v tc &> /dev/null; then
        missing_deps+=("iproute2")
    fi
    
    if [[ $EUID -ne 0 ]]; then
        log "ERROR: Root privileges required for hping3 and tc qdisc"
        exit 1
    fi
    
    if [ ${#missing_deps[@]} -gt 0 ]; then
        log "ERROR: Missing dependencies: ${missing_deps[*]}"
        log "Install with: apt-get install ${missing_deps[*]}"
        exit 1
    fi
    
    if ! ip link show "$INTERFACE" &>/dev/null; then
        log "ERROR: Interface $INTERFACE does not exist"
        log "Available interfaces:"
        ip link show | grep -E "^[0-9]+:" | awk -F: '{print "  " $2}' | tee -a "$LOG_FILE"
        exit 1
    fi
    
    # Test bc functionality
    local bc_test=$(echo "scale=2; 10/3" | bc -l 2>/dev/null)
    if [ -z "$bc_test" ]; then
        log "ERROR: bc calculator not working properly"
        exit 1
    fi
    
    log "Dependencies check passed"
}

show_usage() {
    cat << EOF
Usage: $0 [TARGET_IP] [INTERFACE] [DURATION] [COMPRESSION]

FIXES IN THIS VERSION:
    - Fixed syntax error in calculate_hourly_rate() function
    - Fixed day of week calculation boundary issue
    - Enhanced error handling for bc calculations
    - Increased BURST_SIZE to 4m to properly support high rates
    - Added comprehensive validation for all calculations

PARAMETERS:
    TARGET_IP     - Target IP (default: 8.8.8.8)
    INTERFACE     - Network interface (default: eth0)
    DURATION      - Real duration in seconds (default: 300)
    COMPRESSION   - Time compression factor (default: 72)

EXAMPLE:
    $0 192.168.1.120 eth0 300 288

TECHNICAL NOTES:
    - Requires root privileges for tc qdisc manipulation
    - Packet size: ${PACKET_SIZE} bytes
    - TC burst size: ${BURST_SIZE} (supports high rates)
    - TC latency: ${LATENCY}

MONITORING:
    - Monitor TC qdisc: tc -s qdisc show dev [interface]
    - Log file: ${LOG_FILE}
EOF
}

main() {
    log "=== FIXED TC QDISC OPTIMIZED HPING3 TRAFFIC SIMULATOR ==="
    log "Target: $TARGET_IP"
    log "Interface: $INTERFACE"
    log "Duration: ${DURATION}s"
    log "Compression: ${TIME_COMPRESSION}x"
    log "Packet Size: ${PACKET_SIZE} bytes"
    log "TC Burst: ${BURST_SIZE}, Latency: ${LATENCY}"
    log "FIXES: Syntax errors corrected, enhanced error handling"
    
    check_dependencies
    
    if ! ping -c 1 -W 2 "$TARGET_IP" &>/dev/null; then
        log "WARNING: Target $TARGET_IP may not be reachable"
    fi
    
    generate_compressed_pattern_tc "$DURATION"
    
    log "=== SIMULATION COMPLETED ==="
    log "Log file: $LOG_FILE"
}

if [[ "$1" == "-h" || "$1" == "--help" ]]; then
    show_usage
    exit 0
fi

main "$@"
