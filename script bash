#!/bin/bash

# =================================================================
# OPTIMIZED HPING3 TRAFFIC SIMULATOR WITH TIME COMPRESSION
# =================================================================

set -euo pipefail  # Exit on error, undefined vars, pipe failures thì trả lại error ở command bị fail

# Cấu hình mặc định với readonly
readonly SCRIPT_NAME=$(basename "$0")
readonly SCRIPT_DIR=$(dirname "$(realpath "$0")")
readonly PID_FILE="/tmp/${SCRIPT_NAME}.pid"
readonly DEFAULT_LOG_DIR="./logs"

# Tạo thư mục log nếu chưa tồn tại
mkdir -p "$DEFAULT_LOG_DIR"

# Cấu hình với validation
TARGET_IP="${1:-8.8.8.8}"
INTERFACE="${2:-$(ip route | grep '^default' | grep -o 'dev [^ ]*' | cut -d' ' -f2 | head -1)}"         # Tự lấy tên card mạng thay vì để user nhập vào
DURATION="${3:-300}"
TIME_COMPRESSION="${4:-72}"
MODE="${5:-compressed}"
YOYO_TYPE="${6:-square}"

readonly TARGET_IP INTERFACE DURATION TIME_COMPRESSION MODE YOYO_TYPE
readonly LOG_FILE="${DEFAULT_LOG_DIR}/hping3_traffic_$(date +%Y%m%d_%H%M%S).log"
readonly VERBOSE=${VERBOSE:-true}

# Mảng để lưu PIDs của background processes
declare -a BACKGROUND_PIDS=()

# Trap để cleanup khi script kết thúc
cleanup() {
    local exit_code=$?
    log "Cleaning up..."
    
    # Kill all background processes, lặp theo all IDs
    for pid in "${BACKGROUND_PIDS[@]}"; do
        if kill -0 "$pid" 2>/dev/null; then
            kill "$pid" 2>/dev/null && wait "$pid" 2>/dev/null || true
        fi
    done
    
    # Kill all hping3 processes
    pkill -f "hping3.*$TARGET_IP" 2>/dev/null || true
    
    # Remove PID file
    [[ -f "$PID_FILE" ]] && rm -f "$PID_FILE"
    
    log "Cleanup completed with exit code: $exit_code"
    exit $exit_code
}

trap cleanup EXIT INT TERM

# ghi log vào file log
log() {
    local level="${2:-INFO}"
    local message="$1"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    printf "[%s] [%s] %s\n" "$timestamp" "$level" "$message" | tee -a "$LOG_FILE"
}

log_error() { log "$1" "ERROR"; }
log_warn() { log "$1" "WARN"; }
log_debug() { [[ "$VERBOSE" == true ]] && log "$1" "DEBUG"; }

# Validation functions
# Check IP, phải nhỏ hơn 255
validate_ip() {
    local ip="$1"
    if [[ ! $ip =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
        log_error "Invalid IP address: $ip"
        return 1
    fi
    
    IFS='.' read -ra ADDR <<< "$ip"
    for i in "${ADDR[@]}"; do
        if [[ $i -gt 255 ]]; then
            log_error "Invalid IP address: $ip"
            return 1
        fi
    done
    return 0
}

#Check xem network interface name có chính xác không
validate_interface() {
    local iface="$1"
    if ! ip link show "$iface" &>/dev/null; then
        log_error "Interface $iface not found"
        return 1
    fi
    return 0
}

# Check số nguyên dương
validate_numeric() {
    local value="$1"
    local name="$2"
    if ! [[ "$value" =~ ^[0-9]+$ ]]; then
        log_error "$name must be a positive integer: $value"
        return 1
    fi
    return 0
}

# Math helper functions với cache, sử dụng để lưu cặp key  -value, phép toán - kết quả
declare -A MATH_CACHE=()

cached_bc() {
    local expr="$1"
    local precision="${2:-6}"
    local cache_key="${expr}_${precision}"
    
    if [[ -n "${MATH_CACHE[$cache_key]:-}" ]]; then
        echo "${MATH_CACHE[$cache_key]}"
        return
    fi
    
    local result=$(echo "scale=$precision; $expr" | bc -l 2>/dev/null || echo "0")
    MATH_CACHE[$cache_key]="$result"
    echo "$result"
}

# Pre-calculate constants
readonly PI="3.14159265359"
readonly E="2.71828182846"

# Optimized time calculation functions, gộp gọn vào thành 1 hàm so với bản cũ
get_virtual_time() {
    local elapsed_seconds="$1"
    local virtual_seconds=$(cached_bc "$elapsed_seconds * $TIME_COMPRESSION" 0)
    
    local hours=$(( (virtual_seconds / 3600) % 24 ))
    local minutes=$(( (virtual_seconds % 3600) / 60 ))
    local days=$(( (virtual_seconds / 86400) % 7 + 1 ))
    
    printf "%d %d %d" "$hours" "$minutes" "$days"
}

# Optimized traffic calculation với lookup table cho common values
declare -A HOURLY_RATE_CACHE=()

calculate_hourly_rate() {
    local hour="$1"
    
    # Check cache first
    if [[ -n "${HOURLY_RATE_CACHE[$hour]:-}" ]]; then
        echo "${HOURLY_RATE_CACHE[$hour]}"
        return
    fi
    
    local base_rate=50000
    local max_rate=90000
    
    # Optimized mathematical functions
    local morning_peak=$(cached_bc "25 * e(-1 * (($hour - 9) ^ 2) / 6.25)")
    local evening_peak=$(cached_bc "45 * e(-1 * (($hour - 20) ^ 2) / 7.84)")
    local night_drop=$(cached_bc "-15 * e(-1 * (($hour - 2.5) ^ 2) / 3.24)")
    local daily_cycle=$(cached_bc "5 * s($PI * $hour / 12 - $PI/2)")
    
    local traffic_factor=$(cached_bc "20000 + $morning_peak + $evening_peak + $night_drop + $daily_cycle")
    local pps=$(cached_bc "if($traffic_factor < 5) 5 else $base_rate + ($traffic_factor - 20) * ($max_rate - $base_rate) / 45" 0)
    
    # Cache result
    HOURLY_RATE_CACHE[$hour]="$pps"
    echo "$pps"
}

# Weekly multiplier với cache
declare -A WEEKLY_CACHE=()

calculate_weekly_multiplier() {
    local day="$1"
    
    if [[ -n "${WEEKLY_CACHE[$day]:-}" ]]; then
        echo "${WEEKLY_CACHE[$day]}"
        return
    fi
    
    local base=87
    local sine_component=$(cached_bc "8 * s(2 * $PI * $day / 7 + $PI/7)")
    local weekend_spike=$(cached_bc "5 * e(-1 * (($day - 6) ^ 2) / 2.25)")
    local weekly_factor=$(cached_bc "($base + $sine_component + $weekend_spike) / $base")
    
    WEEKLY_CACHE[$day]="$weekly_factor"
    echo "$weekly_factor"
}

# Optimized hping3 execution với connection pooling concept
run_hping3_optimized() {
    local target="$1"
    local rate="$2" 
    local duration="$3"
    
    # Validate and sanitize rate
    local rate_int=$(cached_bc "$rate" 0)
    rate_int=${rate_int%.*}  # Remove decimal part
    [[ $rate_int -lt 1 ]] && rate_int=1
    [[ $rate_int -gt 100000 ]] && rate_int=100000  # Rate limit
    
    local interval_us=$(cached_bc "1000000 / $rate_int" 0)
    local total_packets=$(cached_bc "$rate_int * $duration" 0)
    [[ ${total_packets%.*} -lt 1 ]] && total_packets=1
    
    log_debug "hping3: ${rate_int}pps for ${duration}s (${total_packets} packets)"
    
    # Use timeout để tránh hanging
    timeout "$duration" hping3 \
        -S -p 80 \
        -i "u${interval_us%.*}" \
        -c "${total_packets%.*}" \
        --interface "$INTERFACE" \
        "$target" \
        >>"$LOG_FILE" 2>&1 &
    
    local pid=$!
    BACKGROUND_PIDS+=($pid)
    echo "$pid"
}

# Pattern generators với optimized loops
generate_compressed_pattern() {
    local duration_seconds="$1"
    
    log "=== TIME COMPRESSION SIMULATION ==="
    log "Compression: ${TIME_COMPRESSION}x | Duration: ${duration_seconds}s"
    log "Virtual time: $(cached_bc "$duration_seconds * $TIME_COMPRESSION / 3600" 1)h"
    
    local update_interval=5
    local current_time=0
    local pids_to_cleanup=()
    
    while [[ $current_time -lt $duration_seconds ]]; do
        # Get virtual time components
        read -r virtual_hour virtual_minute virtual_day <<< "$(get_virtual_time $current_time)"
        
        # Calculate rates
        local hourly_rate=$(calculate_hourly_rate "$virtual_hour")
        local weekly_multiplier=$(calculate_weekly_multiplier "$virtual_day")
        local minute_factor=$(cached_bc "1 + 0.3 * s(2 * $PI * $virtual_minute / 60)")
        
        # Combine factors with optimized calculation
        local base_rate=$(cached_bc "$hourly_rate * $weekly_multiplier * $minute_factor")
        local noise=$(cached_bc "(($RANDOM % 40) - 20) / 100")
        local final_rate=$(cached_bc "($base_rate * (1 + $noise))" 0)
        
        # Ensure minimum rate
        final_rate=${final_rate%.*}
        [[ $final_rate -lt 1 ]] && final_rate=1
        
        # Progress indicator
        local progress=$(cached_bc "$current_time * 100 / $duration_seconds" 0)
        log "Progress: ${progress%.*}% | T+${current_time}s | Virtual: Day${virtual_day} ${virtual_hour}:$(printf "%02d" "$virtual_minute") | Rate: ${final_rate}pps"
        
        # Run hping3
        local hping_pid=$(run_hping3_optimized "$TARGET_IP" "$final_rate" "$update_interval")
        pids_to_cleanup+=($hping_pid)
        
        # Cleanup old processes (keep array size manageable)
        if [[ ${#pids_to_cleanup[@]} -gt 10 ]]; then
            for old_pid in "${pids_to_cleanup[@]:0:5}"; do
                kill "$old_pid" 2>/dev/null || true
            done
            pids_to_cleanup=("${pids_to_cleanup[@]:5}")
        fi
        
        sleep "$update_interval"
        current_time=$((current_time + update_interval))
    done
    
    # Final cleanup
    for pid in "${pids_to_cleanup[@]}"; do
        kill "$pid" 2>/dev/null || true
    done
}

# Optimized Yo-Yo patterns với function pointer concept, tăng tính mở rộng, bảo trì
declare -A YOYO_PATTERNS=(
    ["square"]="yoyo_square"
    ["sawtooth"]="yoyo_sawtooth"
    ["sine"]="yoyo_sine"
    ["burst"]="yoyo_burst"
    ["step"]="yoyo_step"
    ["random"]="yoyo_random"
)

yoyo_square() {
    local cycle_pos="$1"
    local is_first_half=$(cached_bc "$cycle_pos < 0.5" 0)
    [[ ${is_first_half%.*} -eq 1 ]] && echo "80" || echo "20"
}

yoyo_sawtooth() {
    local cycle_pos="$1"
    local is_ramp=$(cached_bc "$cycle_pos < 0.8" 0)
    if [[ ${is_ramp%.*} -eq 1 ]]; then
        cached_bc "10 + 90 * $cycle_pos / 0.8" 0
    else
        echo "10"
    fi
}

yoyo_sine() {
    local cycle_pos="$1"
    cached_bc "50 + 45 * s(2 * $PI * $cycle_pos)" 0
}

yoyo_burst() {
    local cycle_pos="$1"
    local is_burst=$(cached_bc "$cycle_pos < 0.1" 0)
    local is_cooldown=$(cached_bc "$cycle_pos < 0.2" 0)
    
    if [[ ${is_burst%.*} -eq 1 ]]; then
        echo "200"
    elif [[ ${is_cooldown%.*} -eq 1 ]]; then
        echo "50"
    else
        echo "5"
    fi
}

yoyo_step() {
    local cycle_pos="$1"
    local step1=$(cached_bc "$cycle_pos < 0.25" 0)
    local step2=$(cached_bc "$cycle_pos < 0.5" 0) 
    local step3=$(cached_bc "$cycle_pos < 0.75" 0)
    
    if [[ ${step1%.*} -eq 1 ]]; then echo "20"
    elif [[ ${step2%.*} -eq 1 ]]; then echo "50"
    elif [[ ${step3%.*} -eq 1 ]]; then echo "80"
    else echo "100"
    fi
}

yoyo_random() {
    local cycle_pos="$1"
    local phase1=$(cached_bc "$cycle_pos < 0.3" 0)
    local phase2=$(cached_bc "$cycle_pos < 0.7" 0)
    local random_factor=$(cached_bc "($RANDOM % 50) / 100" 2)
    
    if [[ ${phase1%.*} -eq 1 ]]; then
        cached_bc "80 + 20 * $random_factor" 0
    elif [[ ${phase2%.*} -eq 1 ]]; then
        cached_bc "40 + 30 * $random_factor" 0
    else
        cached_bc "5 + 15 * $random_factor" 0
    fi
}

generate_yoyo_pattern() {
    local duration_seconds="$1"
    local yoyo_type="$2"
    
    # Validate pattern type
    if [[ -z "${YOYO_PATTERNS[$yoyo_type]:-}" ]]; then
        log_error "Unknown yo-yo pattern: $yoyo_type"
        return 1
    fi
    
    log "=== YO-YO PATTERN: $yoyo_type ==="
    log "Duration: ${duration_seconds}s"
    
    local update_interval=2
    local cycle_duration=20
    local current_time=0
    local pattern_func="${YOYO_PATTERNS[$yoyo_type]}"
    
    while [[ $current_time -lt $duration_seconds ]]; do
        local cycle_position=$(cached_bc "($current_time % $cycle_duration) / $cycle_duration" 4)
        local rate=$($pattern_func "$cycle_position")
        rate=${rate%.*}
        [[ $rate -lt 1 ]] && rate=1
        
        log "T+${current_time}s | Cycle: $(printf "%.2f" "$cycle_position") | Rate: ${rate}pps"
        
        local hping_pid=$(run_hping3_optimized "$TARGET_IP" "$rate" "$update_interval")
        
        sleep "$update_interval"
        kill "$hping_pid" 2>/dev/null || true
        
        current_time=$((current_time + update_interval))
    done
}

# Enhanced dependency check
check_dependencies() {
    local deps=("hping3" "bc" "timeout" "ip" "pkill")
    local missing=()
    
    for dep in "${deps[@]}"; do
        if ! command -v "$dep" &>/dev/null; then
            missing+=("$dep")
        fi
    done
    
    if [[ ${#missing[@]} -gt 0 ]]; then
        log_error "Missing dependencies: ${missing[*]}"
        log "Install with: apt-get install ${missing[*]}"
        exit 1
    fi
    
    # Check permissions
    if [[ $EUID -ne 0 ]]; then
        log_warn "Root privileges recommended for hping3"
    fi
    
    # Check if another instance is running
    if [[ -f "$PID_FILE" ]] && kill -0 "$(cat "$PID_FILE")" 2>/dev/null; then
        log_error "Another instance is already running (PID: $(cat "$PID_FILE"))"
        exit 1
    fi
    
    echo $$ > "$PID_FILE"
}

# Enhanced connectivity test
test_connectivity() {
    log "Testing connectivity to $TARGET_IP..."
    
    if ! timeout 5 ping -c 2 -W 2 "$TARGET_IP" &>/dev/null; then
        log_warn "Target $TARGET_IP may not be reachable"
        return 1
    fi
    
    # Test interface
    if ! timeout 3 ping -I "$INTERFACE" -c 1 -W 2 "$TARGET_IP" &>/dev/null; then
        log_warn "Interface $INTERFACE may have connectivity issues"
        return 1
    fi
    
    log "Connectivity test passed"
    return 0
}

# Performance monitoring
monitor_performance() {
    while true; do
        local cpu_usage=$(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | cut -d'%' -f1)
        local mem_usage=$(free | grep '^Mem' | awk '{printf "%.1f", $3/$2 * 100.0}')
        local hping_count=$(pgrep -c hping3 || echo 0)
        
        log_debug "Performance: CPU=${cpu_usage}% MEM=${mem_usage}% HPING_PROCS=${hping_count}"
        sleep 30
    done &
    
    BACKGROUND_PIDS+=($!)
}

# Enhanced usage display
show_usage() {
    cat << 'EOF'
HPING3 Traffic Simulator - Optimized Version

USAGE:
    ./script.sh [TARGET] [INTERFACE] [DURATION] [COMPRESSION] [MODE] [YOYO_TYPE]

PARAMETERS:
    TARGET       Target IP address (default: 8.8.8.8)
    INTERFACE    Network interface (auto-detect if not specified)
    DURATION     Duration in seconds (default: 300)
    COMPRESSION  Time compression factor (default: 72)
    MODE         Simulation mode (compressed|yoyo|demo|yoyo-demo)
    YOYO_TYPE    Pattern type for yoyo mode (square|sawtooth|sine|burst|step|random)

EXAMPLES:
    # Standard compressed simulation (5 min = 6 virtual hours)
    ./script.sh 192.168.1.1 eth0 300 72 compressed
    
    # Bot-like square wave pattern
    ./script.sh 8.8.8.8 wlan0 180 1 yoyo square
    
    # Demo all yo-yo patterns
    ./script.sh 1.1.1.1 eth0 600 1 yoyo-demo
    
    # Ultra-fast compression (5 min = 7 virtual days)
    ./script.sh 8.8.8.8 eth0 300 2016 compressed

ENVIRONMENT VARIABLES:
    VERBOSE=true|false    Enable debug logging (default: true)
EOF
}

# Main execution với error handling
main() {
    # Validate inputs
    validate_ip "$TARGET_IP" || exit 1
    validate_interface "$INTERFACE" || exit 1
    validate_numeric "$DURATION" "Duration" || exit 1
    validate_numeric "$TIME_COMPRESSION" "Compression" || exit 1
    
    log "=== OPTIMIZED HPING3 TRAFFIC SIMULATOR ==="
    log "Target: $TARGET_IP | Interface: $INTERFACE"
    log "Duration: ${DURATION}s | Compression: ${TIME_COMPRESSION}x | Mode: $MODE"
    
    check_dependencies
    test_connectivity || log_warn "Proceeding despite connectivity issues"
    
    # Start performance monitoring in verbose mode
    [[ "$VERBOSE" == true ]] && monitor_performance
    
    # Execute based on mode
    case "$MODE" in
        "compressed")
            generate_compressed_pattern "$DURATION"
            ;;
        "yoyo")
            generate_yoyo_pattern "$DURATION" "$YOYO_TYPE"
            ;;
        "demo"|"yoyo-demo")
            log "Demo mode: Running multiple patterns..."
            for pattern in square sawtooth burst step; do
                log "Demo: $pattern pattern (60s)"
                generate_yoyo_pattern 60 "$pattern"
                sleep 5
            done
            ;;
        *)
            log_error "Unknown mode: $MODE"
            show_usage
            exit 1
            ;;
    esac
    
    log "=== SIMULATION COMPLETED SUCCESSFULLY ==="
}

# Command line processing
case "${1:-}" in
    -h|--help) show_usage; exit 0 ;;
    -v|--version) echo "HPING3 Traffic Simulator v2.0 (Optimized)"; exit 0 ;;
esac

main "$@"
